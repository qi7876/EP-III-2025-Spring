diff -Naur linux/boot/boot.s linux_working/linux-0.01-master/boot/boot.s
--- linux/boot/boot.s	1991-09-13 02:40:02.000000000 +0530
+++ linux_working/linux-0.01-master/boot/boot.s	2013-09-18 12:48:30.000000000 +0530
@@ -1,41 +1,41 @@
-|
-|	boot.s
-|
-| boot.s is loaded at 0x7c00 by the bios-startup routines, and moves itself
-| out of the way to address 0x90000, and jumps there.
-|
-| It then loads the system at 0x10000, using BIOS interrupts. Thereafter
-| it disables all interrupts, moves the system down to 0x0000, changes
-| to protected mode, and calls the start of system. System then must
-| RE-initialize the protected mode in it's own tables, and enable
-| interrupts as needed.
-|
-| NOTE! currently system is at most 8*65536 bytes long. This should be no
-| problem, even in the future. I want to keep it simple. This 512 kB
-| kernel size should be enough - in fact more would mean we'd have to move
-| not just these start-up routines, but also do something about the cache-
-| memory (block IO devices). The area left over in the lower 640 kB is meant
-| for these. No other memory is assumed to be "physical", ie all memory
-| over 1Mb is demand-paging. All addresses under 1Mb are guaranteed to match
-| their physical addresses.
-|
-| NOTE1 abouve is no longer valid in it's entirety. cache-memory is allocated
-| above the 1Mb mark as well as below. Otherwise it is mainly correct.
-|
-| NOTE 2! The boot disk type must be set at compile-time, by setting
-| the following equ. Having the boot-up procedure hunt for the right
-| disk type is severe brain-damage.
-| The loader has been made as simple as possible (had to, to get it
-| in 512 bytes with the code to move to protected mode), and continuos
-| read errors will result in a unbreakable loop. Reboot by hand. It
-| loads pretty fast by getting whole sectors at a time whenever possible.
+;
+;	boot.s
+;
+; boot.s is loaded at 0x7c00 by the bios-startup routines, and moves itself
+; out of the way to address 0x90000, and jumps there.
+;
+; It then loads the system at 0x10000, using BIOS interrupts. Thereafter
+; it disables all interrupts, moves the system down to 0x0000, changes
+; to protected mode, and calls the start of system. System then must
+; RE-initialize the protected mode in it's own tables, and enable
+; interrupts as needed.
+;
+; NOTE! currently system is at most 8*65536 bytes long. This should be no
+; problem, even in the future. I want to keep it simple. This 512 kB
+; kernel size should be enough - in fact more would mean we'd have to move
+; not just these start-up routines, but also do something about the cache-
+; memory (block IO devices). The area left over in the lower 640 kB is meant
+; for these. No other memory is assumed to be "physical", ie all memory
+; over 1Mb is demand-paging. All addresses under 1Mb are guaranteed to match
+; their physical addresses.
+;
+; NOTE1 abouve is no longer valid in it's entirety. cache-memory is allocated
+; above the 1Mb mark as well as below. Otherwise it is mainly correct.
+;
+; NOTE 2! The boot disk type must be set at compile-time, by setting
+; the following equ. Having the boot-up procedure hunt for the right
+; disk type is severe brain-damage.
+; The loader has been made as simple as possible (had to, to get it
+; in 512 bytes with the code to move to protected mode), and continuos
+; read errors will result in a unbreakable loop. Reboot by hand. It
+; loads pretty fast by getting whole sectors at a time whenever possible.
 
-| 1.44Mb disks:
+; 1.44Mb disks:
 sectors = 18
-| 1.2Mb disks:
-| sectors = 15
-| 720kB disks:
-| sectors = 9
+; 1.2Mb disks:
+; sectors = 15
+; 720kB disks:
+; sectors = 9
 
 .globl begtext, begdata, begbss, endtext, enddata, endbss
 .text
@@ -48,7 +48,7 @@
 
 BOOTSEG = 0x07c0
 INITSEG = 0x9000
-SYSSEG  = 0x1000			| system loaded at 0x10000 (65536).
+SYSSEG  = 0x1000			; system loaded at 0x10000 (65536).
 ENDSEG	= SYSSEG + SYSSIZE
 
 entry start
@@ -67,48 +67,48 @@
 	mov	ds,ax
 	mov	es,ax
 	mov	ss,ax
-	mov	sp,#0x400		| arbitrary value >>512
+	mov	sp,#0x400		; arbitrary value >>512
 
-	mov	ah,#0x03	| read cursor pos
+	mov	ah,#0x03	; read cursor pos
 	xor	bh,bh
 	int	0x10
 	
 	mov	cx,#24
-	mov	bx,#0x0007	| page 0, attribute 7 (normal)
+	mov	bx,#0x0007	; page 0, attribute 7 (normal)
 	mov	bp,#msg1
-	mov	ax,#0x1301	| write string, move cursor
+	mov	ax,#0x1301	; write string, move cursor
 	int	0x10
 
-| ok, we've written the message, now
-| we want to load the system (at 0x10000)
+; ok, we've written the message, now
+; we want to load the system (at 0x10000)
 
 	mov	ax,#SYSSEG
-	mov	es,ax		| segment of 0x010000
+	mov	es,ax		; segment of 0x010000
 	call	read_it
 	call	kill_motor
 
-| if the read went well we get current cursor position ans save it for
-| posterity.
+; if the read went well we get current cursor position ans save it for
+; posterity.
 
-	mov	ah,#0x03	| read cursor pos
+	mov	ah,#0x03	; read cursor pos
 	xor	bh,bh
-	int	0x10		| save it in known place, con_init fetches
-	mov	[510],dx	| it from 0x90510.
+	int	0x10		; save it in known place, con_init fetches
+	mov	[510],dx	; it from 0x90510.
 		
-| now we want to move to protected mode ...
+; now we want to move to protected mode ...
 
-	cli			| no interrupts allowed !
+	cli			; no interrupts allowed !
 
-| first we move the system to it's rightful place
+; first we move the system to it's rightful place
 
 	mov	ax,#0x0000
-	cld			| 'direction'=0, movs moves forward
+	cld			; 'direction'=0, movs moves forward
 do_move:
-	mov	es,ax		| destination segment
+	mov	es,ax		; destination segment
 	add	ax,#0x1000
 	cmp	ax,#0x9000
 	jz	end_move
-	mov	ds,ax		| source segment
+	mov	ds,ax		; source segment
 	sub	di,di
 	sub	si,si
 	mov 	cx,#0x8000
@@ -116,105 +116,105 @@
 	movsw
 	j	do_move
 
-| then we load the segment descriptors
+; then we load the segment descriptors
 
 end_move:
 
-	mov	ax,cs		| right, forgot this at first. didn't work :-)
+	mov	ax,cs		; right, forgot this at first. didn't work :-)
 	mov	ds,ax
-	lidt	idt_48		| load idt with 0,0
-	lgdt	gdt_48		| load gdt with whatever appropriate
+	lidt	idt_48		; load idt with 0,0
+	lgdt	gdt_48		; load gdt with whatever appropriate
 
-| that was painless, now we enable A20
+; that was painless, now we enable A20
 
 	call	empty_8042
-	mov	al,#0xD1		| command write
+	mov	al,#0xD1		; command write
 	out	#0x64,al
 	call	empty_8042
-	mov	al,#0xDF		| A20 on
+	mov	al,#0xDF		; A20 on
 	out	#0x60,al
 	call	empty_8042
 
-| well, that went ok, I hope. Now we have to reprogram the interrupts :-(
-| we put them right after the intel-reserved hardware interrupts, at
-| int 0x20-0x2F. There they won't mess up anything. Sadly IBM really
-| messed this up with the original PC, and they haven't been able to
-| rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,
-| which is used for the internal hardware interrupts as well. We just
-| have to reprogram the 8259's, and it isn't fun.
-
-	mov	al,#0x11		| initialization sequence
-	out	#0x20,al		| send it to 8259A-1
-	.word	0x00eb,0x00eb		| jmp $+2, jmp $+2
-	out	#0xA0,al		| and to 8259A-2
+; well, that went ok, I hope. Now we have to reprogram the interrupts :-(
+; we put them right after the intel-reserved hardware interrupts, at
+; int 0x20-0x2F. There they won't mess up anything. Sadly IBM really
+; messed this up with the original PC, and they haven't been able to
+; rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,
+; which is used for the internal hardware interrupts as well. We just
+; have to reprogram the 8259's, and it isn't fun.
+
+	mov	al,#0x11		; initialization sequence
+	out	#0x20,al		; send it to 8259A-1
+	.word	0x00eb,0x00eb		; jmp $+2, jmp $+2
+	out	#0xA0,al		; and to 8259A-2
 	.word	0x00eb,0x00eb
-	mov	al,#0x20		| start of hardware int's (0x20)
+	mov	al,#0x20		; start of hardware int's (0x20)
 	out	#0x21,al
 	.word	0x00eb,0x00eb
-	mov	al,#0x28		| start of hardware int's 2 (0x28)
+	mov	al,#0x28		; start of hardware int's 2 (0x28)
 	out	#0xA1,al
 	.word	0x00eb,0x00eb
-	mov	al,#0x04		| 8259-1 is master
+	mov	al,#0x04		; 8259-1 is master
 	out	#0x21,al
 	.word	0x00eb,0x00eb
-	mov	al,#0x02		| 8259-2 is slave
+	mov	al,#0x02		; 8259-2 is slave
 	out	#0xA1,al
 	.word	0x00eb,0x00eb
-	mov	al,#0x01		| 8086 mode for both
+	mov	al,#0x01		; 8086 mode for both
 	out	#0x21,al
 	.word	0x00eb,0x00eb
 	out	#0xA1,al
 	.word	0x00eb,0x00eb
-	mov	al,#0xFF		| mask off all interrupts for now
+	mov	al,#0xFF		; mask off all interrupts for now
 	out	#0x21,al
 	.word	0x00eb,0x00eb
 	out	#0xA1,al
 
-| well, that certainly wasn't fun :-(. Hopefully it works, and we don't
-| need no steenking BIOS anyway (except for the initial loading :-).
-| The BIOS-routine wants lots of unnecessary data, and it's less
-| "interesting" anyway. This is how REAL programmers do it.
-|
-| Well, now's the time to actually move into protected mode. To make
-| things as simple as possible, we do no register set-up or anything,
-| we let the gnu-compiled 32-bit programs do that. We just jump to
-| absolute address 0x00000, in 32-bit protected mode.
-
-	mov	ax,#0x0001	| protected mode (PE) bit
-	lmsw	ax		| This is it!
-	jmpi	0,8		| jmp offset 0 of segment 8 (cs)
-
-| This routine checks that the keyboard command queue is empty
-| No timeout is used - if this hangs there is something wrong with
-| the machine, and we probably couldn't proceed anyway.
+; well, that certainly wasn't fun :-(. Hopefully it works, and we don't
+; need no steenking BIOS anyway (except for the initial loading :-).
+; The BIOS-routine wants lots of unnecessary data, and it's less
+; "interesting" anyway. This is how REAL programmers do it.
+;
+; Well, now's the time to actually move into protected mode. To make
+; things as simple as possible, we do no register set-up or anything,
+; we let the gnu-compiled 32-bit programs do that. We just jump to
+; absolute address 0x00000, in 32-bit protected mode.
+
+	mov	ax,#0x0001	; protected mode (PE) bit
+	lmsw	ax		; This is it!
+	jmpi	0,8		; jmp offset 0 of segment 8 (cs)
+
+; This routine checks that the keyboard command queue is empty
+; No timeout is used - if this hangs there is something wrong with
+; the machine, and we probably couldn't proceed anyway.
 empty_8042:
 	.word	0x00eb,0x00eb
-	in	al,#0x64	| 8042 status port
-	test	al,#2		| is input buffer full?
-	jnz	empty_8042	| yes - loop
+	in	al,#0x64	; 8042 status port
+	test	al,#2		; is input buffer full?
+	jnz	empty_8042	; yes - loop
 	ret
 
-| This routine loads the system at address 0x10000, making sure
-| no 64kB boundaries are crossed. We try to load it as fast as
-| possible, loading whole tracks whenever we can.
-|
-| in:	es - starting address segment (normally 0x1000)
-|
-| This routine has to be recompiled to fit another drive type,
-| just change the "sectors" variable at the start of the file
-| (originally 18, for a 1.44Mb drive)
-|
-sread:	.word 1			| sectors read of current track
-head:	.word 0			| current head
-track:	.word 0			| current track
+; This routine loads the system at address 0x10000, making sure
+; no 64kB boundaries are crossed. We try to load it as fast as
+; possible, loading whole tracks whenever we can.
+;
+; in:	es - starting address segment (normally 0x1000)
+;
+; This routine has to be recompiled to fit another drive type,
+; just change the "sectors" variable at the start of the file
+; (originally 18, for a 1.44Mb drive)
+;
+sread:	.word 1			; sectors read of current track
+head:	.word 0			; current head
+track:	.word 0			; current track
 read_it:
 	mov ax,es
 	test ax,#0x0fff
-die:	jne die			| es must be at 64kB boundary
-	xor bx,bx		| bx is starting address within segment
+die:	jne die			; es must be at 64kB boundary
+	xor bx,bx		; bx is starting address within segment
 rp_read:
 	mov ax,es
-	cmp ax,#ENDSEG		| have we loaded all yet?
+	cmp ax,#ENDSEG		; have we loaded all yet?
 	jb ok1_read
 	ret
 ok1_read:
@@ -296,25 +296,25 @@
 	ret
 
 gdt:
-	.word	0,0,0,0		| dummy
+	.word	0,0,0,0		; dummy
 
-	.word	0x07FF		| 8Mb - limit=2047 (2048*4096=8Mb)
-	.word	0x0000		| base address=0
-	.word	0x9A00		| code read/exec
-	.word	0x00C0		| granularity=4096, 386
-
-	.word	0x07FF		| 8Mb - limit=2047 (2048*4096=8Mb)
-	.word	0x0000		| base address=0
-	.word	0x9200		| data read/write
-	.word	0x00C0		| granularity=4096, 386
+	.word	0x07FF		; 8Mb - limit=2047 (2048*4096=8Mb)
+	.word	0x0000		; base address=0
+	.word	0x9A00		; code read/exec
+	.word	0x00C0		; granularity=4096, 386
+
+	.word	0x07FF		; 8Mb - limit=2047 (2048*4096=8Mb)
+	.word	0x0000		; base address=0
+	.word	0x9200		; data read/write
+	.word	0x00C0		; granularity=4096, 386
 
 idt_48:
-	.word	0			| idt limit=0
-	.word	0,0			| idt base=0L
+	.word	0			; idt limit=0
+	.word	0,0			; idt base=0L
 
 gdt_48:
-	.word	0x800		| gdt limit=2048, 256 GDT entries
-	.word	gdt,0x9		| gdt base = 0X9xxxx
+	.word	0x800		; gdt limit=2048, 256 GDT entries
+	.word	gdt,0x9		; gdt base = 0X9xxxx
 	
 msg1:
 	.byte 13,10
diff -Naur linux/boot/head.s linux_working/linux-0.01-master/boot/head.s
--- linux/boot/head.s	1991-09-12 03:40:39.000000000 +0530
+++ linux_working/linux-0.01-master/boot/head.s	2013-09-18 12:48:30.000000000 +0530
@@ -5,16 +5,17 @@
  * the page directory will exist. The startup code will be overwritten by
  * the page directory.
  */
+.code32
 .text
-.globl _idt,_gdt,_pg_dir
-_pg_dir:
+.globl idt,gdt,pg_dir,startup_32
+pg_dir:
 startup_32:
 	movl $0x10,%eax
 	mov %ax,%ds
 	mov %ax,%es
 	mov %ax,%fs
 	mov %ax,%gs
-	lss _stack_start,%esp
+	lss stack_start,%esp
 	call setup_idt
 	call setup_gdt
 	movl $0x10,%eax		# reload all the segment registers
@@ -22,7 +23,7 @@
 	mov %ax,%es		# reloaded in 'setup_gdt'
 	mov %ax,%fs
 	mov %ax,%gs
-	lss _stack_start,%esp
+	lss stack_start,%esp
 	xorl %eax,%eax
 1:	incl %eax		# check that A20 really IS enabled
 	movl %eax,0x000000
@@ -53,7 +54,7 @@
 	movw %dx,%ax		/* selector = 0x0008 = cs */
 	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */
 
-	lea _idt,%edi
+	lea idt,%edi
 	mov $256,%ecx
 rp_sidt:
 	movl %eax,(%edi)
@@ -95,7 +96,7 @@
 	pushl $0
 	pushl $0
 	pushl $L6		# return address for main, if it decides to.
-	pushl $_main
+	pushl $main
 	jmp setup_paging
 L6:
 	jmp L6			# main should never return here, but
@@ -139,8 +140,8 @@
 	xorl %eax,%eax
 	xorl %edi,%edi			/* pg_dir is at 0x000 */
 	cld;rep;stosl
-	movl $pg0+7,_pg_dir		/* set present bit/user r/w */
-	movl $pg1+7,_pg_dir+4		/*  --------- " " --------- */
+	movl $pg0+7,pg_dir		/* set present bit/user r/w */
+	movl $pg1+7,pg_dir+4		/*  --------- " " --------- */
 	movl $pg1+4092,%edi
 	movl $0x7ff007,%eax		/*  8Mb - 4096 + 7 (r/w user,p) */
 	std
@@ -158,17 +159,17 @@
 .word 0
 idt_descr:
 	.word 256*8-1		# idt contains 256 entries
-	.long _idt
+	.long idt
 .align 2
 .word 0
 gdt_descr:
 	.word 256*8-1		# so does gdt (not that that's any
-	.long _gdt		# magic number, but it works for me :^)
+	.long gdt		# magic number, but it works for me :^)
 
-	.align 3
-_idt:	.fill 256,8,0		# idt is uninitialized
+	.align 8
+idt:	.fill 256,8,0		# idt is uninitialized
 
-_gdt:	.quad 0x0000000000000000	/* NULL descriptor */
+gdt:	.quad 0x0000000000000000	/* NULL descriptor */
 	.quad 0x00c09a00000007ff	/* 8Mb */
 	.quad 0x00c09200000007ff	/* 8Mb */
 	.quad 0x0000000000000000	/* TEMPORARY - don't use */
diff -Naur linux/fs/bitmap.c linux_working/linux-0.01-master/fs/bitmap.c
--- linux/fs/bitmap.c	1991-09-09 23:32:48.000000000 +0530
+++ linux_working/linux-0.01-master/fs/bitmap.c	2013-09-18 12:48:30.000000000 +0530
@@ -8,15 +8,15 @@
 __asm__("cld\n\t" \
 	"rep\n\t" \
 	"stosl" \
-	::"a" (0),"c" (BLOCK_SIZE/4),"D" ((long) (addr)):"cx","di")
+	::"a" (0),"c" (BLOCK_SIZE/4),"D" ((long) (addr))/*:"cx","di"*/)
 
 #define set_bit(nr,addr) ({\
-register int res __asm__("ax"); \
+register int res;/* __asm__("ax");*/ \
 __asm__("btsl %2,%3\n\tsetb %%al":"=a" (res):"0" (0),"r" (nr),"m" (*(addr))); \
 res;})
 
 #define clear_bit(nr,addr) ({\
-register int res __asm__("ax"); \
+register int res;/* __asm__("ax");*/ \
 __asm__("btrl %2,%3\n\tsetnb %%al":"=a" (res):"0" (0),"r" (nr),"m" (*(addr))); \
 res;})
 
@@ -33,7 +33,7 @@
 	"cmpl $8192,%%ecx\n\t" \
 	"jl 1b\n" \
 	"3:" \
-	:"=c" (__res):"c" (0),"S" (addr):"ax","dx","si"); \
+	:"=c" (__res):"c" (0),"S" (addr):"ax","dx"/*,"si"*/); \
 __res;})
 
 void free_block(int dev, int block)
@@ -74,7 +74,7 @@
 		panic("trying to get new block from nonexistant device");
 	j = 8192;
 	for (i=0 ; i<8 ; i++)
-		if (bh=sb->s_zmap[i])
+		if ((bh=sb->s_zmap[i]))
 			if ((j=find_first_zero(bh->b_data))<8192)
 				break;
 	if (i>=8 || !bh || j>=8192)
@@ -138,7 +138,7 @@
 		panic("new_inode with unknown device");
 	j = 8192;
 	for (i=0 ; i<8 ; i++)
-		if (bh=sb->s_imap[i])
+		if ((bh=sb->s_imap[i]))
 			if ((j=find_first_zero(bh->b_data))<8192)
 				break;
 	if (!bh || j >= 8192 || j+i*8192 > sb->s_ninodes) {
diff -Naur linux/fs/block_dev.c linux_working/linux-0.01-master/fs/block_dev.c
--- linux/fs/block_dev.c	1991-09-14 01:08:04.000000000 +0530
+++ linux_working/linux-0.01-master/fs/block_dev.c	2013-09-18 12:48:30.000000000 +0530
@@ -77,7 +77,7 @@
 
 void ll_rw_block(int rw, struct buffer_head * bh)
 {
-	blk_fn blk_addr;
+	blk_fn blk_addr=NULL;
 	unsigned int major;
 
 	if ((major=MAJOR(bh->b_dev)) >= NR_BLK_DEV || !(blk_addr=rd_blk[major]))
diff -Naur linux/fs/buffer.c linux_working/linux-0.01-master/fs/buffer.c
--- linux/fs/buffer.c	1991-09-17 20:35:51.000000000 +0530
+++ linux_working/linux-0.01-master/fs/buffer.c	2013-09-18 12:48:30.000000000 +0530
@@ -146,7 +146,7 @@
 	struct buffer_head * tmp;
 
 repeat:
-	if (tmp=get_hash_table(dev,block))
+	if ((tmp=get_hash_table(dev,block)))
 		return tmp;
 	tmp = free_list;
 	do {
diff -Naur linux/fs/char_dev.c linux_working/linux-0.01-master/fs/char_dev.c
--- linux/fs/char_dev.c	1991-09-08 19:03:45.000000000 +0530
+++ linux_working/linux-0.01-master/fs/char_dev.c	2013-09-18 12:48:30.000000000 +0530
@@ -9,7 +9,7 @@
 static int rw_ttyx(int rw,unsigned minor,char * buf,int count);
 static int rw_tty(int rw,unsigned minor,char * buf,int count);
 
-typedef (*crw_ptr)(int rw,unsigned minor,char * buf,int count);
+typedef int (*crw_ptr)(int rw,unsigned minor,char * buf,int count);
 
 #define NRDEVS ((sizeof (crw_table))/(sizeof (crw_ptr)))
 
diff -Naur linux/fs/exec.c linux_working/linux-0.01-master/fs/exec.c
--- linux/fs/exec.c	1991-09-13 19:54:30.000000000 +0530
+++ linux_working/linux-0.01-master/fs/exec.c	2013-09-18 12:48:30.000000000 +0530
@@ -1,6 +1,16 @@
+
+/*
+ *  linux/fs/exec.c
+ *
+ *  (C) 1991  Linus Torvalds
+ *  (C) 2007  Abdel Benamrouche : use elf binary instead of a.out
+ * 
+ */
+
+
 #include <errno.h>
 #include <sys/stat.h>
-#include <a.out.h>
+#include <elf.h>
 
 #include <linux/fs.h>
 #include <linux/sched.h>
@@ -18,95 +28,29 @@
  */
 #define MAX_ARG_PAGES 32
 
-#define cp_block(from,to) \
-__asm__("pushl $0x10\n\t" \
-	"pushl $0x17\n\t" \
-	"pop %%es\n\t" \
-	"cld\n\t" \
-	"rep\n\t" \
-	"movsl\n\t" \
-	"pop %%es" \
-	::"c" (BLOCK_SIZE/4),"S" (from),"D" (to) \
-	:"cx","di","si")
-
-/*
- * read_head() reads blocks 1-6 (not 0). Block 0 has already been
- * read for header information.
- */
-int read_head(struct m_inode * inode,int blocks)
+inline void cp_block(const void * from,void * to, int size)
 {
-	struct buffer_head * bh;
-	int count;
-
-	if (blocks>6)
-		blocks=6;
-	for(count = 0 ; count<blocks ; count++) {
-		if (!inode->i_zone[count+1])
-			continue;
-		if (!(bh=bread(inode->i_dev,inode->i_zone[count+1])))
-			return -1;
-		cp_block(bh->b_data,count*BLOCK_SIZE);
-		brelse(bh);
-	}
-	return 0;
+int d0,d1,d2;
+__asm__ __volatile("pushl $0x10\n\t"
+	"pushl $0x17\n\t"
+	"pop %%es\n\t"
+	"cld\n\t"
+	"rep\n\t"
+	"movsl\n\t"
+	"pop %%es"
+	:"=&c" (d0), "=&S" (d1), "=&D" (d2)
+	:"0" (size/4),"1" (from),"2" (to)
+	:"memory");
 }
 
-int read_ind(int dev,int ind,long size,unsigned long offset)
+typedef struct
 {
-	struct buffer_head * ih, * bh;
-	unsigned short * table,block;
-
-	if (size<=0)
-		panic("size<=0 in read_ind");
-	if (size>512*BLOCK_SIZE)
-		size=512*BLOCK_SIZE;
-	if (!ind)
-		return 0;
-	if (!(ih=bread(dev,ind)))
-		return -1;
-	table = (unsigned short *) ih->b_data;
-	while (size>0) {
-		if (block=*(table++))
-			if (!(bh=bread(dev,block))) {
-				brelse(ih);
-				return -1;
-			} else {
-				cp_block(bh->b_data,offset);
-				brelse(bh);
-			}
-		size -= BLOCK_SIZE;
-		offset += BLOCK_SIZE;
-	}
-	brelse(ih);
-	return 0;
-}
+	unsigned long b_entry;
+	unsigned long b_size;				//file size
+}bin_section;
 
-/*
- * read_area() reads an area into %fs:mem.
- */
-int read_area(struct m_inode * inode,long size)
-{
-	struct buffer_head * dind;
-	unsigned short * table;
-	int i,count;
 
-	if ((i=read_head(inode,(size+BLOCK_SIZE-1)/BLOCK_SIZE)) ||
-	    (size -= BLOCK_SIZE*6)<=0)
-		return i;
-	if ((i=read_ind(inode->i_dev,inode->i_zone[7],size,BLOCK_SIZE*6)) ||
-	    (size -= BLOCK_SIZE*512)<=0)
-		return i;
-	if (!(i=inode->i_zone[8]))
-		return 0;
-	if (!(dind = bread(inode->i_dev,i)))
-		return -1;
-	table = (unsigned short *) dind->b_data;
-	for(count=0 ; count<512 ; count++)
-		if ((i=read_ind(inode->i_dev,*(table++),size,
-		    BLOCK_SIZE*(518+count))) || (size -= BLOCK_SIZE*512)<=0)
-			return i;
-	panic("Impossibly long executable");
-}
+#include <string.h>
 
 /*
  * create_tables() parses the env- and arg-strings in new user
@@ -123,8 +67,8 @@
 	envp = sp;
 	sp -= argc+1;
 	argv = sp;
-	put_fs_long((unsigned long)envp,--sp);
-	put_fs_long((unsigned long)argv,--sp);
+	//put_fs_long((unsigned long)envp,--sp);
+	//put_fs_long((unsigned long)argv,--sp);
 	put_fs_long((unsigned long)argc,--sp);
 	while (argc-->0) {
 		put_fs_long((unsigned long) p,argv++);
@@ -147,7 +91,7 @@
 	int i=0;
 	char ** tmp;
 
-	if (tmp = argv)
+	if ((tmp = argv))
 		while (get_fs_long((unsigned long *) (tmp++)))
 			i++;
 
@@ -217,6 +161,222 @@
 }
 
 /*
+ * return 1 if ex if a valid elf executable
+ * */
+int is_valid_elf(Elf32_Ehdr* ex)
+{
+	if (ex->e_ident[EI_MAG0]!=ELFMAG0 || ex->e_ident[EI_MAG1]!=ELFMAG1 ||
+		ex->e_ident[EI_MAG2]!=ELFMAG2 || ex->e_ident[EI_MAG3]!=ELFMAG3){
+		printk("not elf format\n");
+		return 0;	/*not elf format */
+	}
+
+	if (ex->e_type != ET_EXEC || ex->e_machine != EM_386){
+		printk("bad elf binary\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * bread(dev,ind) is an array of block index
+ * So we have to get from this array our wanted index ( variable block)
+ * */
+struct buffer_head* read_file_block_ind(int dev,int ind,int block_num)
+{
+	struct buffer_head * bh=NULL,*ih;
+	unsigned short block;
+
+	if (!(ih=bread(dev,ind)))
+	{
+		printk("bad block tab\n");
+		return NULL;
+	}
+
+	if ((block = *((unsigned short *) (ih->b_data) + block_num))){
+		if (!(bh=bread(dev,block))) {
+			brelse(ih);
+			printk("bad block file\n");
+			return NULL;
+		}
+	}
+
+
+	brelse(ih);
+	return bh;
+}
+
+/*
+ * if block_num=5, read file at position 5*1024.
+ * this work only for minix 1 fs 
+ */
+struct buffer_head* read_file_block(struct m_inode * inode,int block_num)
+{
+	struct buffer_head * dind;
+	int i;
+	unsigned short table;
+
+	 /* 7 1st block can be read directly */
+	if (block_num<=6)
+	{
+		return bread(inode->i_dev,inode->i_zone[block_num]);
+	}
+
+	block_num-=7;
+
+	if (block_num<512)
+	{
+		/* read block at i_zone[7] is an array of block index */
+		return read_file_block_ind(inode->i_dev,inode->i_zone[7],block_num);
+	}
+
+	block_num-=512;
+
+	if (block_num>512*512)
+	{
+		panic("Impossibly long executable");
+		return NULL;	//just to avoid warning compilation
+	}
+
+	/* i_zone[8] => array of array block index */
+	if (!(i=inode->i_zone[8]))
+		return NULL;
+	if (!(dind = bread(inode->i_dev,i)))
+		return NULL;
+	
+	table = *((unsigned short *) dind->b_data+(block_num/512));
+	brelse(dind);
+	if (block_num>=512)
+		block_num-=(block_num-1)*512;
+	
+	return read_file_block_ind(inode->i_dev,table,block_num);
+}
+
+
+/*  
+ *  read an area into %fs:mem.
+ */
+int copy_section(struct m_inode * inode,Elf32_Off from, Elf32_Addr dest,Elf32_Word size)
+{
+	struct buffer_head * bh;
+	int block_num=from/BLOCK_SIZE;
+	int block_offset;			//only for 1st block
+	int cp_size;				
+
+	//read fist block
+	block_offset=from%BLOCK_SIZE;
+	bh=read_file_block(inode,block_num);
+	if (!bh) return -1;
+	cp_size=(size<BLOCK_SIZE-block_offset)?size:BLOCK_SIZE-block_offset;
+	//note we add 3 to size to get it aligned to word boundary
+	cp_block(bh->b_data+block_offset,(void*)dest,cp_size+3);
+	brelse(bh);
+	dest+=cp_size;
+	size-=cp_size;
+	block_num++;
+
+	//read others blocks
+	while(size)
+	{
+		bh=read_file_block(inode,block_num);
+		if (!bh) return -1;
+		cp_size=(size<BLOCK_SIZE)?size:BLOCK_SIZE;
+		cp_block(bh->b_data,(void*)dest,cp_size+3);
+		block_num++;
+		size-=cp_size;
+		dest+=cp_size;
+		brelse(bh);
+	};
+
+	return 0;
+}
+
+inline int create_bss_section(Elf32_Addr dest,Elf32_Word size)
+{
+	while (size--)
+		put_fs_byte(0,(char *)dest++);
+	return 0;
+}
+
+/*
+ * in linux 0.01 only a.out binary format was supported
+ * Today it's hard to compile some programs (like bach) in a.out format
+ * So this version of linux 0.01 support elf binary.
+ * nb : there is no support of shared library !
+ */
+int load_elf_binary(struct m_inode *inode, struct buffer_head* bh,
+					 bin_section* bs)
+{
+	Elf32_Ehdr ex;
+	Elf32_Shdr sect;
+	long nsect;
+	int lb=0;
+	struct buffer_head* bht=NULL;
+
+	ex = *((Elf32_Ehdr *) bh->b_data);	/* read exec-header */
+
+	/* check header */
+	if (!is_valid_elf(&ex)) {
+		return -1;
+	}
+
+	bs->b_entry=ex.e_entry;
+	nsect=ex.e_shnum;
+	bs->b_size=ex.e_ehsize+nsect*ex.e_shentsize;
+	
+	if (nsect<=1){
+		printk("bad nb of sections %d\n",nsect);
+		return -1;
+	}
+	
+	while(nsect--){
+	
+		/* load block where is our table section*/
+		if ((ex.e_shoff + nsect * ex.e_shentsize)/BLOCK_SIZE != lb)
+		{
+			printk("");	// gcc  bug : removing this line = gcc not happy !!!
+			lb = (ex.e_shoff + nsect * ex.e_shentsize)/BLOCK_SIZE;
+			if (bht) brelse(bht);
+			bht=read_file_block(inode,lb);
+			if (!bht) return -1;
+		}
+
+		/* copy this section fo %fs:mem */
+		sect=*((Elf32_Shdr *)(bht->b_data + (ex.e_shoff + 
+				nsect * ex.e_shentsize)%BLOCK_SIZE ));
+	
+		if (!sect.sh_size || !sect.sh_addr) continue;
+		
+		switch(sect.sh_type)
+		{
+			case SHT_PROGBITS:
+				if (copy_section(inode,sect.sh_offset,sect.sh_addr,
+					sect.sh_size))
+				{
+					if (bht) brelse(bht);
+					return -1;
+				}
+				break;
+			
+			case SHT_NOBITS:	  
+				create_bss_section(sect.sh_addr,sect.sh_size);
+				break;
+
+			default:
+			continue;	  
+		}
+
+		/* find binary size */
+		if (bs->b_size<sect.sh_addr + sect.sh_size)
+			bs->b_size=sect.sh_addr + sect.sh_size;	
+	};
+
+	if (bht) brelse(bht);
+	return 0;
+}
+
+/*
  * 'do_execve()' executes a new program.
  */
 int do_execve(unsigned long * eip,long tmp,char * filename,
@@ -224,10 +384,10 @@
 {
 	struct m_inode * inode;
 	struct buffer_head * bh;
-	struct exec ex;
 	unsigned long page[MAX_ARG_PAGES];
 	int i,argc,envc;
 	unsigned long p;
+	bin_section bs;
 
 	if ((0xffff & eip[1]) != 0x000f)
 		panic("execve called from supervisor mode");
@@ -235,7 +395,7 @@
 		page[i]=0;
 	if (!(inode=namei(filename)))		/* get executables inode */
 		return -ENOENT;
-	if (!S_ISREG(inode->i_mode)) {	/* must be regular file */
+	if (!S_ISREG(inode->i_mode)) {		/* must be regular file */
 		iput(inode);
 		return -EACCES;
 	}
@@ -255,19 +415,10 @@
 		iput(inode);
 		return -EACCES;
 	}
-	ex = *((struct exec *) bh->b_data);	/* read exec-header */
-	brelse(bh);
-	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
-		ex.a_text+ex.a_data+ex.a_bss>0x3000000 ||
-		inode->i_size < ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) {
-		iput(inode);
-		return -ENOEXEC;
-	}
-	if (N_TXTOFF(ex) != BLOCK_SIZE)
-		panic("N_TXTOFF != BLOCK_SIZE. See a.out.h.");
+
 	argc = count(argv);
 	envc = count(envp);
-	p = copy_strings(envc,envp,page,PAGE_SIZE*MAX_ARG_PAGES-4);
+	p = copy_strings(envc,envp,page,PAGE_SIZE*MAX_ARG_PAGES);
 	p = copy_strings(argc,argv,page,p);
 	if (!p) {
 		for (i=0 ; i<MAX_ARG_PAGES ; i++)
@@ -282,25 +433,34 @@
 		if ((current->close_on_exec>>i)&1)
 			sys_close(i);
 	current->close_on_exec = 0;
+
 	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
 	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
+	
+	if (load_elf_binary(inode,bh,&bs)){
+		brelse(bh);
+		iput(inode);
+		return -EACCES;
+	}
+	brelse(bh);
+
 	if (last_task_used_math == current)
 		last_task_used_math = NULL;
 	current->used_math = 0;
-	p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;
+	p += change_ldt(bs.b_size,page)-MAX_ARG_PAGES*PAGE_SIZE;
 	p = (unsigned long) create_tables((char *)p,argc,envc);
-	current->brk = ex.a_bss +
-		(current->end_data = ex.a_data +
-		(current->end_code = ex.a_text));
+	current->brk = bs.b_size;
+	current->end_data = bs.b_size;
+	current->end_code = bs.b_size;
 	current->start_stack = p & 0xfffff000;
-	i = read_area(inode,ex.a_text+ex.a_data);
 	iput(inode);
-	if (i<0)
-		sys_exit(-1);
-	i = ex.a_text+ex.a_data;
+
+	i = bs.b_size;
 	while (i&0xfff)
 		put_fs_byte(0,(char *) (i++));
-	eip[0] = ex.a_entry;		/* eip, magic happens :-) */
-	eip[3] = p;			/* stack pointer */
+	
+	eip[0] = bs.b_entry;		/* eip, magic happens :-) */
+	eip[3] = p;					/* stack pointer */
+
 	return 0;
 }
diff -Naur linux/fs/fcntl.c linux_working/linux-0.01-master/fs/fcntl.c
--- linux/fs/fcntl.c	1991-08-30 19:36:25.000000000 +0530
+++ linux_working/linux-0.01-master/fs/fcntl.c	2013-09-18 12:48:30.000000000 +0530
@@ -67,3 +67,25 @@
 			return -1;
 	}
 }
+
+
+int sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	struct file * filp;
+
+	if (fd >= NR_OPEN || !(filp = current->filp[fd]))
+		return -EBADF;
+	
+	switch(cmd)
+	{
+		case F_GETLK64:
+		case F_SETLK64:
+		case F_SETLKW64:
+			return -ENOSYS;
+		
+		default:
+			return sys_fcntl(fd,cmd,arg);
+	}
+
+}
+
diff -Naur linux/fs/file_dev.c linux_working/linux-0.01-master/fs/file_dev.c
--- linux/fs/file_dev.c	1991-08-30 20:47:58.000000000 +0530
+++ linux_working/linux-0.01-master/fs/file_dev.c	2013-09-18 12:48:30.000000000 +0530
@@ -16,7 +16,7 @@
 	if ((left=count)<=0)
 		return 0;
 	while (left) {
-		if (nr = bmap(inode,(filp->f_pos)/BLOCK_SIZE)) {
+		if ((nr = bmap(inode,(filp->f_pos)/BLOCK_SIZE))) {
 			if (!(bh=bread(inode->i_dev,nr)))
 				break;
 		} else
diff -Naur linux/fs/inode.c linux_working/linux-0.01-master/fs/inode.c
--- linux/fs/inode.c	1991-09-09 23:36:58.000000000 +0530
+++ linux_working/linux-0.01-master/fs/inode.c	2013-09-18 12:48:30.000000000 +0530
@@ -57,7 +57,7 @@
 		panic("_bmap: block>big");
 	if (block<7) {
 		if (create && !inode->i_zone[block])
-			if (inode->i_zone[block]=new_block(inode->i_dev)) {
+			if ((inode->i_zone[block]=new_block(inode->i_dev))) {
 				inode->i_ctime=CURRENT_TIME;
 				inode->i_dirt=1;
 			}
@@ -66,7 +66,7 @@
 	block -= 7;
 	if (block<512) {
 		if (create && !inode->i_zone[7])
-			if (inode->i_zone[7]=new_block(inode->i_dev)) {
+			if ((inode->i_zone[7]=new_block(inode->i_dev))) {
 				inode->i_dirt=1;
 				inode->i_ctime=CURRENT_TIME;
 			}
@@ -76,7 +76,7 @@
 			return 0;
 		i = ((unsigned short *) (bh->b_data))[block];
 		if (create && !i)
-			if (i=new_block(inode->i_dev)) {
+			if ((i=new_block(inode->i_dev))) {
 				((unsigned short *) (bh->b_data))[block]=i;
 				bh->b_dirt=1;
 			}
@@ -85,7 +85,7 @@
 	}
 	block -= 512;
 	if (create && !inode->i_zone[8])
-		if (inode->i_zone[8]=new_block(inode->i_dev)) {
+		if ((inode->i_zone[8]=new_block(inode->i_dev))) {
 			inode->i_dirt=1;
 			inode->i_ctime=CURRENT_TIME;
 		}
@@ -95,7 +95,7 @@
 		return 0;
 	i = ((unsigned short *)bh->b_data)[block>>9];
 	if (create && !i)
-		if (i=new_block(inode->i_dev)) {
+		if ((i=new_block(inode->i_dev))) {
 			((unsigned short *) (bh->b_data))[block>>9]=i;
 			bh->b_dirt=1;
 		}
@@ -106,7 +106,7 @@
 		return 0;
 	i = ((unsigned short *)bh->b_data)[block&511];
 	if (create && !i)
-		if (i=new_block(inode->i_dev)) {
+		if ((i=new_block(inode->i_dev))) {
 			((unsigned short *) (bh->b_data))[block&511]=i;
 			bh->b_dirt=1;
 		}
diff -Naur linux/fs/Makefile linux_working/linux-0.01-master/fs/Makefile
--- linux/fs/Makefile	1991-09-17 20:44:55.000000000 +0530
+++ linux_working/linux-0.01-master/fs/Makefile	2013-09-18 12:48:30.000000000 +0530
@@ -1,9 +1,9 @@
-AR	=gar
-AS	=gas
+AR	=ar
+AS	=as --32
 CC	=gcc
-LD	=gld
-CFLAGS	=-Wall -O -fstrength-reduce -fcombine-regs -fomit-frame-pointer \
-	-mstring-insns -nostdinc -I../include
+LD	=ld -m  elf_i386
+CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -m32 \
+	 -fno-stack-protector -nostdinc -fno-builtin -g -I../include
 CPP	=gcc -E -nostdinc -I../include
 
 .c.s:
@@ -17,7 +17,7 @@
 
 OBJS=	open.o read_write.o inode.o file_table.o buffer.o super.o \
 	block_dev.o char_dev.o file_dev.o stat.o exec.o pipe.o namei.o \
-	bitmap.o fcntl.o ioctl.o tty_ioctl.o truncate.o
+	bitmap.o fcntl.o ioctl.o tty_ioctl.o truncate.o sys_getdents.o
 
 fs.o: $(OBJS)
 	$(LD) -r -o fs.o $(OBJS)
@@ -44,7 +44,7 @@
   ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \
   ../include/linux/mm.h ../include/linux/kernel.h 
 exec.o : exec.c ../include/errno.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/a.out.h ../include/linux/fs.h \
+  ../include/sys/types.h ../include/elf.h ../include/linux/fs.h \
   ../include/linux/sched.h ../include/linux/head.h ../include/linux/mm.h \
   ../include/linux/kernel.h ../include/asm/segment.h 
 fcntl.o : fcntl.c ../include/string.h ../include/errno.h \
diff -Naur linux/fs/namei.c linux_working/linux-0.01-master/fs/namei.c
--- linux/fs/namei.c	1991-09-13 01:02:07.000000000 +0530
+++ linux_working/linux-0.01-master/fs/namei.c	2013-09-18 12:48:30.000000000 +0530
@@ -63,7 +63,7 @@
 		"setz %%al"
 		:"=a" (same)
 		:"0" (0),"S" ((long) name),"D" ((long) de->name),"c" (len)
-		:"cx","di","si");
+		/*:"cx","di","si"*/);
 	return same;
 }
 
@@ -255,7 +255,7 @@
 	if (!(dir = get_dir(pathname)))
 		return NULL;
 	basename = pathname;
-	while (c=get_fs_byte(pathname++))
+	while ((c=get_fs_byte(pathname++)))
 		if (c=='/')
 			basename=pathname;
 	*namelen = pathname-basename-1;
diff -Naur linux/fs/open.c linux_working/linux-0.01-master/fs/open.c
--- linux/fs/open.c	1991-09-08 19:44:18.000000000 +0530
+++ linux_working/linux-0.01-master/fs/open.c	2013-09-18 12:48:30.000000000 +0530
@@ -39,11 +39,12 @@
 		return -EACCES;
 	res = inode->i_mode & 0777;
 	iput(inode);
-	if (!(current->euid && current->uid))
+	if (!(current->euid && current->uid)) {
 		if (res & 0111)
 			res = 0777;
 		else
 			res = 0666;
+	}
 	if (current->euid == inode->i_uid)
 		res >>= 6;
 	else if (current->egid == inode->i_gid)
@@ -89,12 +90,13 @@
 
 	if (!(inode=namei(filename)))
 		return -ENOENT;
-	if (current->uid && current->euid)
+	if (current->uid && current->euid) {
 		if (current->uid!=inode->i_uid && current->euid!=inode->i_uid) {
 			iput(inode);
 			return -EACCES;
 		} else 
 			mode = (mode & 0777) | (inode->i_mode & 07000);
+	}
 	inode->i_mode = (mode & 07777) | (inode->i_mode & ~07777);
 	inode->i_dirt = 1;
 	iput(inode);
@@ -143,7 +145,7 @@
 		return i;
 	}
 /* ttys are somewhat special (ttyxx major==4, tty major==5) */
-	if (S_ISCHR(inode->i_mode))
+	if (S_ISCHR(inode->i_mode)) {
 		if (MAJOR(inode->i_zone[0])==4) {
 			if (current->leader && current->tty<0) {
 				current->tty = MINOR(inode->i_zone[0]);
@@ -156,6 +158,7 @@
 				f->f_count=0;
 				return -EPERM;
 			}
+	}
 	f->f_mode = inode->i_mode;
 	f->f_flags = flag;
 	f->f_count = 1;
diff -Naur linux/fs/stat.c linux_working/linux-0.01-master/fs/stat.c
--- linux/fs/stat.c	1991-09-12 02:05:53.000000000 +0530
+++ linux_working/linux-0.01-master/fs/stat.c	2013-09-18 12:48:30.000000000 +0530
@@ -40,6 +40,11 @@
 	return i;
 }
 
+int sys_lstat(char* filename, struct stat * statbuf)
+{
+	return sys_stat(filename,statbuf);
+}
+
 int sys_fstat(unsigned int fd, struct stat * statbuf)
 {
 	struct file * f;
@@ -49,3 +54,66 @@
 		return -ENOENT;
 	return cp_stat(inode,statbuf);
 }
+
+
+static int cp_stat64(struct m_inode * inode, struct stat64 * statbuf)
+{
+	struct stat64 tmp;
+	int i;
+
+	verify_area(statbuf,sizeof (* statbuf));
+	tmp.st_dev = inode->i_dev;
+	tmp.st_ino = inode->i_num;
+	tmp.st_mode = inode->i_mode;
+	tmp.st_nlink = inode->i_nlinks;
+	tmp.st_uid = inode->i_uid;
+	tmp.st_gid = inode->i_gid;
+	tmp.st_rdev = inode->i_zone[0];
+	tmp.st_size = inode->i_size;
+	tmp.st_atime = inode->i_atime;
+	tmp.st_mtime = inode->i_mtime;
+	tmp.st_ctime = inode->i_ctime;
+	for (i=0 ; i<sizeof (tmp) ; i++)
+		put_fs_byte(((char *) &tmp)[i],&((char *) statbuf)[i]);
+	return (0);
+}
+
+int sys_stat64(char * filename, struct stat64 * statbuf)
+{
+	int i;
+	struct m_inode * inode;
+
+	if (!(inode=namei(filename)))
+		return -ENOENT;
+	i=cp_stat64(inode,statbuf);
+	iput(inode);
+	return i;
+}
+
+int sys_fstat64(unsigned int fd, struct stat64 * statbuf)
+{
+	struct file * f;
+	struct m_inode * inode;
+
+	if (fd >= NR_OPEN || !(f=current->filp[fd]) || !(inode=f->f_inode))
+		return -ENOENT;
+	return cp_stat64(inode,statbuf);
+}
+
+int sys_lstat64(char* filename, struct stat * statbuf)
+{
+	return sys_stat64(filename, (struct stat64 *)statbuf);
+}
+
+int sys_oldstat()
+{
+	printk("calling obsolete system call oldstat\n");
+	return 0;
+}
+
+int sys_oldfstat()
+{
+	printk("calling obsolete system call oldfstat\n");
+	return 0;
+}
+
diff -Naur linux/fs/super.c linux_working/linux-0.01-master/fs/super.c
--- linux/fs/super.c	1991-09-17 20:35:51.000000000 +0530
+++ linux_working/linux-0.01-master/fs/super.c	2013-09-18 12:48:30.000000000 +0530
@@ -7,7 +7,7 @@
 
 /* set_bit uses setb, as gas doesn't recognize setc */
 #define set_bit(bitnr,addr) ({ \
-register int __res __asm__("ax"); \
+register int __res;/* __asm__("ax");*/ \
 __asm__("bt %2,%3;setb %%al":"=a" (__res):"a" (0),"r" (bitnr),"m" (*(addr))); \
 __res; })
 
@@ -39,12 +39,12 @@
 		p->s_zmap[i] = NULL;
 	block=2;
 	for (i=0 ; i < p->s_imap_blocks ; i++)
-		if (p->s_imap[i]=bread(dev,block))
+		if ((p->s_imap[i]=bread(dev,block)))
 			block++;
 		else
 			break;
 	for (i=0 ; i < p->s_zmap_blocks ; i++)
-		if (p->s_zmap[i]=bread(dev,block))
+		if ((p->s_zmap[i]=bread(dev,block)))
 			block++;
 		else
 			break;
diff -Naur linux/fs/sys_getdents.c linux_working/linux-0.01-master/fs/sys_getdents.c
--- linux/fs/sys_getdents.c	1970-01-01 05:30:00.000000000 +0530
+++ linux_working/linux-0.01-master/fs/sys_getdents.c	2013-09-18 12:48:30.000000000 +0530
@@ -0,0 +1,124 @@
+
+#include <dirent.h>
+#include <errno.h>
+
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <asm/segment.h>
+#include <sys/stat.h>
+
+struct buffer_head* read_file_block(struct m_inode * inode,int block_num);
+
+static int minix_getdents(struct m_inode * inode, struct file * filp,
+	struct dirent * dirent, int count)
+{
+	unsigned int offset,i;
+	char c;
+	struct buffer_head * bh;
+	struct dir_entry * de;
+
+	if (!inode ||/* !inode->i_sb ||*/ !S_ISDIR(inode->i_mode))
+		return -EBADF;/*
+	info = &inode->i_sb->u.minix_sb;
+	if (filp->f_pos & (info->s_dirsize - 1))
+		return -EBADF;*/
+	while (filp->f_pos < inode->i_size) {
+		offset = filp->f_pos & 1023;
+		bh = read_file_block(inode,(filp->f_pos)/BLOCK_SIZE);
+		if (!bh) {
+			filp->f_pos += 1024-offset;
+			continue;
+		}
+		while (offset < 1024 && filp->f_pos < inode->i_size) {
+			de = (struct dir_entry *) (offset + bh->b_data);
+			offset += sizeof(struct dir_entry);//info->s_dirsize; 
+			filp->f_pos += sizeof(struct dir_entry);
+			if (de->inode) {
+				for (i = 0; i < NAME_LEN; i++)
+					if ((c = de->name[i]) != 0)
+						put_fs_byte(c,i+dirent->d_name);
+					else
+						break;
+				if (i) {
+					put_fs_long(de->inode,&dirent->d_ino);
+					put_fs_byte(0,i+dirent->d_name);
+					put_fs_word(i,&dirent->d_reclen);
+					brelse(bh);
+					return i;
+				}
+			}
+		}
+		brelse(bh);
+	}
+	return 0;
+}
+
+static int minix_getdents64(struct m_inode * inode, struct file * filp,
+	struct dirent64 * dirent, int count)
+{
+	unsigned int offset,i;
+	char c;
+	struct buffer_head * bh;
+	struct dir_entry * de;
+
+	if (!inode ||/* !inode->i_sb ||*/ !S_ISDIR(inode->i_mode))
+		return -EBADF;/*
+	info = &inode->i_sb->u.minix_sb;
+	if (filp->f_pos & (info->s_dirsize - 1))
+		return -EBADF;*/
+	while (filp->f_pos < inode->i_size) {
+		offset = filp->f_pos & 1023;
+		bh = read_file_block(inode,(filp->f_pos)/BLOCK_SIZE);
+		if (!bh) {
+			filp->f_pos += 1024-offset;
+			continue;
+		}
+		while (offset < 1024 && filp->f_pos < inode->i_size) {
+			de = (struct dir_entry *) (offset + bh->b_data);
+			offset += sizeof(struct dir_entry);//info->s_dirsize; 
+			filp->f_pos += sizeof(struct dir_entry);
+			if (de->inode) {
+				for (i = 0; i < NAME_LEN; i++)
+					if ((c = de->name[i]) != 0)
+						put_fs_byte(c,i+dirent->d_name);
+					else
+						break;
+				if (i) {
+					put_fs_long(de->inode,&dirent->d_ino);
+					put_fs_byte(0,i+dirent->d_name);
+					put_fs_word(i,&dirent->d_reclen);
+					brelse(bh);
+					return i;
+				}
+			}
+		}
+		brelse(bh);
+	}
+	return 0;
+}
+
+int sys_getdents(unsigned int fd, struct dirent *dirp, unsigned int count)
+{
+	struct file * file;
+	struct m_inode * inode;
+	if (fd >= NR_OPEN || !(file = current->filp[fd]) ||
+	    !(inode = file->f_inode))
+		return -EBADF;
+
+	verify_area(dirp, sizeof (*dirp));
+	return minix_getdents(inode,file,dirp,count);
+}
+
+int sys_getdents64(unsigned int fd, struct dirent64 *dirp, unsigned int count)
+{
+	struct file * file;
+	struct m_inode * inode;
+	if (fd >= NR_OPEN || !(file = current->filp[fd]) ||
+	    !(inode = file->f_inode))
+		return -EBADF;
+
+	verify_area(dirp, sizeof (*dirp));
+	return minix_getdents64(inode,file,dirp,count);
+}
+
diff -Naur linux/fs/truncate.c linux_working/linux-0.01-master/fs/truncate.c
--- linux/fs/truncate.c	1991-09-07 22:45:10.000000000 +0530
+++ linux_working/linux-0.01-master/fs/truncate.c	2013-09-18 12:48:30.000000000 +0530
@@ -10,7 +10,7 @@
 
 	if (!block)
 		return;
-	if (bh=bread(dev,block)) {
+	if ((bh=bread(dev,block))) {
 		p = (unsigned short *) bh->b_data;
 		for (i=0;i<512;i++,p++)
 			if (*p)
@@ -28,7 +28,7 @@
 
 	if (!block)
 		return;
-	if (bh=bread(dev,block)) {
+	if ((bh=bread(dev,block))) {
 		p = (unsigned short *) bh->b_data;
 		for (i=0;i<512;i++,p++)
 			if (*p)
diff -Naur linux/include/a.out.h linux_working/linux-0.01-master/include/a.out.h
--- linux/include/a.out.h	1991-09-17 20:40:49.000000000 +0530
+++ linux_working/linux-0.01-master/include/a.out.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,220 +0,0 @@
-#ifndef _A_OUT_H
-#define _A_OUT_H
-
-#define __GNU_EXEC_MACROS__
-
-struct exec {
-  unsigned long a_magic;	/* Use macros N_MAGIC, etc for access */
-  unsigned a_text;		/* length of text, in bytes */
-  unsigned a_data;		/* length of data, in bytes */
-  unsigned a_bss;		/* length of uninitialized data area for file, in bytes */
-  unsigned a_syms;		/* length of symbol table data in file, in bytes */
-  unsigned a_entry;		/* start address */
-  unsigned a_trsize;		/* length of relocation info for text, in bytes */
-  unsigned a_drsize;		/* length of relocation info for data, in bytes */
-};
-
-#ifndef N_MAGIC
-#define N_MAGIC(exec) ((exec).a_magic)
-#endif
-
-#ifndef OMAGIC
-/* Code indicating object file or impure executable.  */
-#define OMAGIC 0407
-/* Code indicating pure executable.  */
-#define NMAGIC 0410
-/* Code indicating demand-paged executable.  */
-#define ZMAGIC 0413
-#endif /* not OMAGIC */
-
-#ifndef N_BADMAG
-#define N_BADMAG(x)					\
- (N_MAGIC(x) != OMAGIC && N_MAGIC(x) != NMAGIC		\
-  && N_MAGIC(x) != ZMAGIC)
-#endif
-
-#define _N_BADMAG(x)					\
- (N_MAGIC(x) != OMAGIC && N_MAGIC(x) != NMAGIC		\
-  && N_MAGIC(x) != ZMAGIC)
-
-#define _N_HDROFF(x) (SEGMENT_SIZE - sizeof (struct exec))
-
-#ifndef N_TXTOFF
-#define N_TXTOFF(x) \
- (N_MAGIC(x) == ZMAGIC ? _N_HDROFF((x)) + sizeof (struct exec) : sizeof (struct exec))
-#endif
-
-#ifndef N_DATOFF
-#define N_DATOFF(x) (N_TXTOFF(x) + (x).a_text)
-#endif
-
-#ifndef N_TRELOFF
-#define N_TRELOFF(x) (N_DATOFF(x) + (x).a_data)
-#endif
-
-#ifndef N_DRELOFF
-#define N_DRELOFF(x) (N_TRELOFF(x) + (x).a_trsize)
-#endif
-
-#ifndef N_SYMOFF
-#define N_SYMOFF(x) (N_DRELOFF(x) + (x).a_drsize)
-#endif
-
-#ifndef N_STROFF
-#define N_STROFF(x) (N_SYMOFF(x) + (x).a_syms)
-#endif
-
-/* Address of text segment in memory after it is loaded.  */
-#ifndef N_TXTADDR
-#define N_TXTADDR(x) 0
-#endif
-
-/* Address of data segment in memory after it is loaded.
-   Note that it is up to you to define SEGMENT_SIZE
-   on machines not listed here.  */
-#if defined(vax) || defined(hp300) || defined(pyr)
-#define SEGMENT_SIZE PAGE_SIZE
-#endif
-#ifdef	hp300
-#define	PAGE_SIZE	4096
-#endif
-#ifdef	sony
-#define	SEGMENT_SIZE	0x2000
-#endif	/* Sony.  */
-#ifdef is68k
-#define SEGMENT_SIZE 0x20000
-#endif
-#if defined(m68k) && defined(PORTAR)
-#define PAGE_SIZE 0x400
-#define SEGMENT_SIZE PAGE_SIZE
-#endif
-
-#define PAGE_SIZE 4096
-#define SEGMENT_SIZE 1024
-
-#define _N_SEGMENT_ROUND(x) (((x) + SEGMENT_SIZE - 1) & ~(SEGMENT_SIZE - 1))
-
-#define _N_TXTENDADDR(x) (N_TXTADDR(x)+(x).a_text)
-
-#ifndef N_DATADDR
-#define N_DATADDR(x) \
-    (N_MAGIC(x)==OMAGIC? (_N_TXTENDADDR(x)) \
-     : (_N_SEGMENT_ROUND (_N_TXTENDADDR(x))))
-#endif
-
-/* Address of bss segment in memory after it is loaded.  */
-#ifndef N_BSSADDR
-#define N_BSSADDR(x) (N_DATADDR(x) + (x).a_data)
-#endif
-
-#ifndef N_NLIST_DECLARED
-struct nlist {
-  union {
-    char *n_name;
-    struct nlist *n_next;
-    long n_strx;
-  } n_un;
-  unsigned char n_type;
-  char n_other;
-  short n_desc;
-  unsigned long n_value;
-};
-#endif
-
-#ifndef N_UNDF
-#define N_UNDF 0
-#endif
-#ifndef N_ABS
-#define N_ABS 2
-#endif
-#ifndef N_TEXT
-#define N_TEXT 4
-#endif
-#ifndef N_DATA
-#define N_DATA 6
-#endif
-#ifndef N_BSS
-#define N_BSS 8
-#endif
-#ifndef N_COMM
-#define N_COMM 18
-#endif
-#ifndef N_FN
-#define N_FN 15
-#endif
-
-#ifndef N_EXT
-#define N_EXT 1
-#endif
-#ifndef N_TYPE
-#define N_TYPE 036
-#endif
-#ifndef N_STAB
-#define N_STAB 0340
-#endif
-
-/* The following type indicates the definition of a symbol as being
-   an indirect reference to another symbol.  The other symbol
-   appears as an undefined reference, immediately following this symbol.
-
-   Indirection is asymmetrical.  The other symbol's value will be used
-   to satisfy requests for the indirect symbol, but not vice versa.
-   If the other symbol does not have a definition, libraries will
-   be searched to find a definition.  */
-#define N_INDR 0xa
-
-/* The following symbols refer to set elements.
-   All the N_SET[ATDB] symbols with the same name form one set.
-   Space is allocated for the set in the text section, and each set
-   element's value is stored into one word of the space.
-   The first word of the space is the length of the set (number of elements).
-
-   The address of the set is made into an N_SETV symbol
-   whose name is the same as the name of the set.
-   This symbol acts like a N_DATA global symbol
-   in that it can satisfy undefined external references.  */
-
-/* These appear as input to LD, in a .o file.  */
-#define	N_SETA	0x14		/* Absolute set element symbol */
-#define	N_SETT	0x16		/* Text set element symbol */
-#define	N_SETD	0x18		/* Data set element symbol */
-#define	N_SETB	0x1A		/* Bss set element symbol */
-
-/* This is output from LD.  */
-#define N_SETV	0x1C		/* Pointer to set vector in data area.  */
-
-#ifndef N_RELOCATION_INFO_DECLARED
-
-/* This structure describes a single relocation to be performed.
-   The text-relocation section of the file is a vector of these structures,
-   all of which apply to the text section.
-   Likewise, the data-relocation section applies to the data section.  */
-
-struct relocation_info
-{
-  /* Address (within segment) to be relocated.  */
-  int r_address;
-  /* The meaning of r_symbolnum depends on r_extern.  */
-  unsigned int r_symbolnum:24;
-  /* Nonzero means value is a pc-relative offset
-     and it should be relocated for changes in its own address
-     as well as for changes in the symbol or section specified.  */
-  unsigned int r_pcrel:1;
-  /* Length (as exponent of 2) of the field to be relocated.
-     Thus, a value of 2 indicates 1<<2 bytes.  */
-  unsigned int r_length:2;
-  /* 1 => relocate with value of symbol.
-          r_symbolnum is the index of the symbol
-	  in file's the symbol table.
-     0 => relocate with the address of a segment.
-          r_symbolnum is N_TEXT, N_DATA, N_BSS or N_ABS
-	  (the N_EXT bit may be set also, but signifies nothing).  */
-  unsigned int r_extern:1;
-  /* Four bits that aren't used, but when writing an object file
-     it is desirable to clear them.  */
-  unsigned int r_pad:4;
-};
-#endif /* no N_RELOCATION_INFO_DECLARED.  */
-
-
-#endif /* __A_OUT_GNU_H__ */
diff -Naur linux/include/asm/segment.h linux_working/linux-0.01-master/include/asm/segment.h
--- linux/include/asm/segment.h	1991-08-19 02:44:12.000000000 +0530
+++ linux_working/linux-0.01-master/include/asm/segment.h	2013-09-18 12:48:30.000000000 +0530
@@ -24,7 +24,7 @@
 
 extern inline void put_fs_byte(char val,char *addr)
 {
-__asm__ ("movb %0,%%fs:%1"::"r" (val),"m" (*addr));
+__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
 }
 
 extern inline void put_fs_word(short val,short * addr)
diff -Naur linux/include/bits/wchar.h linux_working/linux-0.01-master/include/bits/wchar.h
--- linux/include/bits/wchar.h	1970-01-01 05:30:00.000000000 +0530
+++ linux_working/linux-0.01-master/include/bits/wchar.h	2013-09-18 12:48:30.000000000 +0530
@@ -0,0 +1,26 @@
+/* wchar_t type related definitions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_WCHAR_H
+#define _BITS_WCHAR_H	1
+
+#define __WCHAR_MIN	(-2147483647l - 1l)
+#define __WCHAR_MAX	(2147483647l)
+
+#endif	/* bits/wchar.h */
diff -Naur linux/include/bits/wordsize.h linux_working/linux-0.01-master/include/bits/wordsize.h
--- linux/include/bits/wordsize.h	1970-01-01 05:30:00.000000000 +0530
+++ linux_working/linux-0.01-master/include/bits/wordsize.h	2013-09-18 12:48:30.000000000 +0530
@@ -0,0 +1,19 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __WORDSIZE	32
diff -Naur linux/include/ctype.h linux_working/linux-0.01-master/include/ctype.h
--- linux/include/ctype.h	1991-09-17 20:38:29.000000000 +0530
+++ linux_working/linux-0.01-master/include/ctype.h	2013-09-18 12:48:30.000000000 +0530
@@ -11,7 +11,7 @@
 #define _SP	0x80	/* hard space (0x20) */
 
 extern unsigned char _ctype[];
-extern char _ctmp;
+extern signed char _ctmp;
 
 #define isalnum(c) ((_ctype+1)[c]&(_U|_L|_D))
 #define isalpha(c) ((_ctype+1)[c]&(_U|_L))
diff -Naur linux/include/dirent.h linux_working/linux-0.01-master/include/dirent.h
--- linux/include/dirent.h	1970-01-01 05:30:00.000000000 +0530
+++ linux_working/linux-0.01-master/include/dirent.h	2013-09-18 12:48:30.000000000 +0530
@@ -0,0 +1,39 @@
+
+#ifndef __DIRENT_H
+#define __DIRENT_H
+
+#include <linux/fs.h>
+#include <stdint.h>
+
+#define NAME_MAX NAME_LEN
+
+struct dirent{
+	long d_ino;
+	off_t d_off;
+	unsigned short d_reclen;
+	char d_name[256];
+};
+
+struct dirent64 {
+  uint64_t	d_ino;
+  int64_t	d_off;
+  uint16_t	d_reclen;
+  unsigned char	d_type;
+  char		d_name[256];
+};
+
+struct __DIR{
+	struct dirent64 d_dent;
+	int d_pos;
+	int d_fd;
+};
+
+#define DIR struct __DIR 
+
+DIR *opendir (const char *name);
+int closedir (DIR *dir);
+struct dirent *readdir (DIR *dir);
+
+#endif 
+
+
diff -Naur linux/include/elf.h linux_working/linux-0.01-master/include/elf.h
--- linux/include/elf.h	1970-01-01 05:30:00.000000000 +0530
+++ linux_working/linux-0.01-master/include/elf.h	2013-09-18 12:48:30.000000000 +0530
@@ -0,0 +1,2561 @@
+/* This file defines standard ELF types, structures, and macros.
+   Copyright (C) 1995-2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _ELF_H
+#define	_ELF_H 1
+
+//#include <features.h>
+
+//__BEGIN_DECLS
+
+/* Standard ELF types.  */
+
+#include <stdint.h>
+
+/* Type for a 16-bit quantity.  */
+typedef uint16_t Elf32_Half;
+typedef uint16_t Elf64_Half;
+
+/* Types for signed and unsigned 32-bit quantities.  */
+typedef uint32_t Elf32_Word;
+typedef	int32_t  Elf32_Sword;
+typedef uint32_t Elf64_Word;
+typedef	int32_t  Elf64_Sword;
+
+/* Types for signed and unsigned 64-bit quantities.  */
+typedef uint64_t Elf32_Xword;
+typedef	int64_t  Elf32_Sxword;
+typedef uint64_t Elf64_Xword;
+typedef	int64_t  Elf64_Sxword;
+
+/* Type of addresses.  */
+typedef uint32_t Elf32_Addr;
+typedef uint64_t Elf64_Addr;
+
+/* Type of file offsets.  */
+typedef uint32_t Elf32_Off;
+typedef uint64_t Elf64_Off;
+
+/* Type for section indices, which are 16-bit quantities.  */
+typedef uint16_t Elf32_Section;
+typedef uint16_t Elf64_Section;
+
+/* Type for version symbol information.  */
+typedef Elf32_Half Elf32_Versym;
+typedef Elf64_Half Elf64_Versym;
+
+
+/* The ELF file header.  This appears at the start of every ELF file.  */
+
+#define EI_NIDENT (16)
+
+typedef struct
+{
+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
+  Elf32_Half	e_type;			/* Object file type */
+  Elf32_Half	e_machine;		/* Architecture */
+  Elf32_Word	e_version;		/* Object file version */
+  Elf32_Addr	e_entry;		/* Entry point virtual address */
+  Elf32_Off	e_phoff;		/* Program header table file offset */
+  Elf32_Off	e_shoff;		/* Section header table file offset */
+  Elf32_Word	e_flags;		/* Processor-specific flags */
+  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
+  Elf32_Half	e_phentsize;		/* Program header table entry size */
+  Elf32_Half	e_phnum;		/* Program header table entry count */
+  Elf32_Half	e_shentsize;		/* Section header table entry size */
+  Elf32_Half	e_shnum;		/* Section header table entry count */
+  Elf32_Half	e_shstrndx;		/* Section header string table index */
+} Elf32_Ehdr;
+
+typedef struct
+{
+  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
+  Elf64_Half	e_type;			/* Object file type */
+  Elf64_Half	e_machine;		/* Architecture */
+  Elf64_Word	e_version;		/* Object file version */
+  Elf64_Addr	e_entry;		/* Entry point virtual address */
+  Elf64_Off	e_phoff;		/* Program header table file offset */
+  Elf64_Off	e_shoff;		/* Section header table file offset */
+  Elf64_Word	e_flags;		/* Processor-specific flags */
+  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
+  Elf64_Half	e_phentsize;		/* Program header table entry size */
+  Elf64_Half	e_phnum;		/* Program header table entry count */
+  Elf64_Half	e_shentsize;		/* Section header table entry size */
+  Elf64_Half	e_shnum;		/* Section header table entry count */
+  Elf64_Half	e_shstrndx;		/* Section header string table index */
+} Elf64_Ehdr;
+
+/* Fields in the e_ident array.  The EI_* macros are indices into the
+   array.  The macros under each EI_* macro are the values the byte
+   may have.  */
+
+#define EI_MAG0		0		/* File identification byte 0 index */
+#define ELFMAG0		0x7f		/* Magic number byte 0 */
+
+#define EI_MAG1		1		/* File identification byte 1 index */
+#define ELFMAG1		'E'		/* Magic number byte 1 */
+
+#define EI_MAG2		2		/* File identification byte 2 index */
+#define ELFMAG2		'L'		/* Magic number byte 2 */
+
+#define EI_MAG3		3		/* File identification byte 3 index */
+#define ELFMAG3		'F'		/* Magic number byte 3 */
+
+/* Conglomeration of the identification bytes, for easy testing as a word.  */
+#define	ELFMAG		"\177ELF"
+#define	SELFMAG		4
+
+#define EI_CLASS	4		/* File class byte index */
+#define ELFCLASSNONE	0		/* Invalid class */
+#define ELFCLASS32	1		/* 32-bit objects */
+#define ELFCLASS64	2		/* 64-bit objects */
+#define ELFCLASSNUM	3
+
+#define EI_DATA		5		/* Data encoding byte index */
+#define ELFDATANONE	0		/* Invalid data encoding */
+#define ELFDATA2LSB	1		/* 2's complement, little endian */
+#define ELFDATA2MSB	2		/* 2's complement, big endian */
+#define ELFDATANUM	3
+
+#define EI_VERSION	6		/* File version byte index */
+					/* Value must be EV_CURRENT */
+
+#define EI_OSABI	7		/* OS ABI identification */
+#define ELFOSABI_NONE		0	/* UNIX System V ABI */
+#define ELFOSABI_SYSV		0	/* Alias.  */
+#define ELFOSABI_HPUX		1	/* HP-UX */
+#define ELFOSABI_NETBSD		2	/* NetBSD.  */
+#define ELFOSABI_LINUX		3	/* Linux.  */
+#define ELFOSABI_SOLARIS	6	/* Sun Solaris.  */
+#define ELFOSABI_AIX		7	/* IBM AIX.  */
+#define ELFOSABI_IRIX		8	/* SGI Irix.  */
+#define ELFOSABI_FREEBSD	9	/* FreeBSD.  */
+#define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX.  */
+#define ELFOSABI_MODESTO	11	/* Novell Modesto.  */
+#define ELFOSABI_OPENBSD	12	/* OpenBSD.  */
+#define ELFOSABI_ARM		97	/* ARM */
+#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
+
+#define EI_ABIVERSION	8		/* ABI version */
+
+#define EI_PAD		9		/* Byte index of padding bytes */
+
+/* Legal values for e_type (object file type).  */
+
+#define ET_NONE		0		/* No file type */
+#define ET_REL		1		/* Relocatable file */
+#define ET_EXEC		2		/* Executable file */
+#define ET_DYN		3		/* Shared object file */
+#define ET_CORE		4		/* Core file */
+#define	ET_NUM		5		/* Number of defined types */
+#define ET_LOOS		0xfe00		/* OS-specific range start */
+#define ET_HIOS		0xfeff		/* OS-specific range end */
+#define ET_LOPROC	0xff00		/* Processor-specific range start */
+#define ET_HIPROC	0xffff		/* Processor-specific range end */
+
+/* Legal values for e_machine (architecture).  */
+
+#define EM_NONE		 0		/* No machine */
+#define EM_M32		 1		/* AT&T WE 32100 */
+#define EM_SPARC	 2		/* SUN SPARC */
+#define EM_386		 3		/* Intel 80386 */
+#define EM_68K		 4		/* Motorola m68k family */
+#define EM_88K		 5		/* Motorola m88k family */
+#define EM_860		 7		/* Intel 80860 */
+#define EM_MIPS		 8		/* MIPS R3000 big-endian */
+#define EM_S370		 9		/* IBM System/370 */
+#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
+
+#define EM_PARISC	15		/* HPPA */
+#define EM_VPP500	17		/* Fujitsu VPP500 */
+#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
+#define EM_960		19		/* Intel 80960 */
+#define EM_PPC		20		/* PowerPC */
+#define EM_PPC64	21		/* PowerPC 64-bit */
+#define EM_S390		22		/* IBM S390 */
+
+#define EM_V800		36		/* NEC V800 series */
+#define EM_FR20		37		/* Fujitsu FR20 */
+#define EM_RH32		38		/* TRW RH-32 */
+#define EM_RCE		39		/* Motorola RCE */
+#define EM_ARM		40		/* ARM */
+#define EM_FAKE_ALPHA	41		/* Digital Alpha */
+#define EM_SH		42		/* Hitachi SH */
+#define EM_SPARCV9	43		/* SPARC v9 64-bit */
+#define EM_TRICORE	44		/* Siemens Tricore */
+#define EM_ARC		45		/* Argonaut RISC Core */
+#define EM_H8_300	46		/* Hitachi H8/300 */
+#define EM_H8_300H	47		/* Hitachi H8/300H */
+#define EM_H8S		48		/* Hitachi H8S */
+#define EM_H8_500	49		/* Hitachi H8/500 */
+#define EM_IA_64	50		/* Intel Merced */
+#define EM_MIPS_X	51		/* Stanford MIPS-X */
+#define EM_COLDFIRE	52		/* Motorola Coldfire */
+#define EM_68HC12	53		/* Motorola M68HC12 */
+#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
+#define EM_PCP		55		/* Siemens PCP */
+#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
+#define EM_NDR1		57		/* Denso NDR1 microprocessor */
+#define EM_STARCORE	58		/* Motorola Start*Core processor */
+#define EM_ME16		59		/* Toyota ME16 processor */
+#define EM_ST100	60		/* STMicroelectronic ST100 processor */
+#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
+#define EM_X86_64	62		/* AMD x86-64 architecture */
+#define EM_PDSP		63		/* Sony DSP Processor */
+
+#define EM_FX66		66		/* Siemens FX66 microcontroller */
+#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
+#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
+#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
+#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
+#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
+#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
+#define EM_SVX		73		/* Silicon Graphics SVx */
+#define EM_ST19		74		/* STMicroelectronics ST19 8 bit mc */
+#define EM_VAX		75		/* Digital VAX */
+#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
+#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
+#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
+#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
+#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
+#define EM_HUANY	81		/* Harvard University machine-independent object files */
+#define EM_PRISM	82		/* SiTera Prism */
+#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
+#define EM_FR30		84		/* Fujitsu FR30 */
+#define EM_D10V		85		/* Mitsubishi D10V */
+#define EM_D30V		86		/* Mitsubishi D30V */
+#define EM_V850		87		/* NEC v850 */
+#define EM_M32R		88		/* Mitsubishi M32R */
+#define EM_MN10300	89		/* Matsushita MN10300 */
+#define EM_MN10200	90		/* Matsushita MN10200 */
+#define EM_PJ		91		/* picoJava */
+#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
+#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
+#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
+#define EM_NUM		95
+
+/* If it is necessary to assign new unofficial EM_* values, please
+   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
+   chances of collision with official or non-GNU unofficial values.  */
+
+#define EM_ALPHA	0x9026
+
+/* Legal values for e_version (version).  */
+
+#define EV_NONE		0		/* Invalid ELF version */
+#define EV_CURRENT	1		/* Current version */
+#define EV_NUM		2
+
+/* Section header.  */
+
+typedef struct
+{
+  Elf32_Word	sh_name;		/* Section name (string tbl index) */
+  Elf32_Word	sh_type;		/* Section type */
+  Elf32_Word	sh_flags;		/* Section flags */
+  Elf32_Addr	sh_addr;		/* Section virtual addr at execution */
+  Elf32_Off	sh_offset;		/* Section file offset */
+  Elf32_Word	sh_size;		/* Section size in bytes */
+  Elf32_Word	sh_link;		/* Link to another section */
+  Elf32_Word	sh_info;		/* Additional section information */
+  Elf32_Word	sh_addralign;		/* Section alignment */
+  Elf32_Word	sh_entsize;		/* Entry size if section holds table */
+} Elf32_Shdr;
+
+typedef struct
+{
+  Elf64_Word	sh_name;		/* Section name (string tbl index) */
+  Elf64_Word	sh_type;		/* Section type */
+  Elf64_Xword	sh_flags;		/* Section flags */
+  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
+  Elf64_Off	sh_offset;		/* Section file offset */
+  Elf64_Xword	sh_size;		/* Section size in bytes */
+  Elf64_Word	sh_link;		/* Link to another section */
+  Elf64_Word	sh_info;		/* Additional section information */
+  Elf64_Xword	sh_addralign;		/* Section alignment */
+  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
+} Elf64_Shdr;
+
+/* Special section indices.  */
+
+#define SHN_UNDEF	0		/* Undefined section */
+#define SHN_LORESERVE	0xff00		/* Start of reserved indices */
+#define SHN_LOPROC	0xff00		/* Start of processor-specific */
+#define SHN_BEFORE	0xff00		/* Order section before all others
+					   (Solaris).  */
+#define SHN_AFTER	0xff01		/* Order section after all others
+					   (Solaris).  */
+#define SHN_HIPROC	0xff1f		/* End of processor-specific */
+#define SHN_LOOS	0xff20		/* Start of OS-specific */
+#define SHN_HIOS	0xff3f		/* End of OS-specific */
+#define SHN_ABS		0xfff1		/* Associated symbol is absolute */
+#define SHN_COMMON	0xfff2		/* Associated symbol is common */
+#define SHN_XINDEX	0xffff		/* Index is in extra table.  */
+#define SHN_HIRESERVE	0xffff		/* End of reserved indices */
+
+/* Legal values for sh_type (section type).  */
+
+#define SHT_NULL	  0		/* Section header table entry unused */
+#define SHT_PROGBITS	  1		/* Program data */
+#define SHT_SYMTAB	  2		/* Symbol table */
+#define SHT_STRTAB	  3		/* String table */
+#define SHT_RELA	  4		/* Relocation entries with addends */
+#define SHT_HASH	  5		/* Symbol hash table */
+#define SHT_DYNAMIC	  6		/* Dynamic linking information */
+#define SHT_NOTE	  7		/* Notes */
+#define SHT_NOBITS	  8		/* Program space with no data (bss) */
+#define SHT_REL		  9		/* Relocation entries, no addends */
+#define SHT_SHLIB	  10		/* Reserved */
+#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
+#define SHT_INIT_ARRAY	  14		/* Array of constructors */
+#define SHT_FINI_ARRAY	  15		/* Array of destructors */
+#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
+#define SHT_GROUP	  17		/* Section group */
+#define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
+#define	SHT_NUM		  19		/* Number of defined types.  */
+#define SHT_LOOS	  0x60000000	/* Start OS-specific */
+#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
+#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
+#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
+#define SHT_SUNW_move	  0x6ffffffa
+#define SHT_SUNW_COMDAT   0x6ffffffb
+#define SHT_SUNW_syminfo  0x6ffffffc
+#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
+#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
+#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
+#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
+#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
+#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
+#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
+#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
+#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
+
+/* Legal values for sh_flags (section flags).  */
+
+#define SHF_WRITE	     (1 << 0)	/* Writable */
+#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
+#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
+#define SHF_MERGE	     (1 << 4)	/* Might be merged */
+#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
+#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
+#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
+#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling
+					   required */
+#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
+#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
+#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
+#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
+#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement
+					   (Solaris).  */
+#define SHF_EXCLUDE	     (1 << 31)	/* Section is excluded unless
+					   referenced or allocated (Solaris).*/
+
+/* Section group handling.  */
+#define GRP_COMDAT	0x1		/* Mark group as COMDAT.  */
+
+/* Symbol table entry.  */
+
+typedef struct
+{
+  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
+  Elf32_Addr	st_value;		/* Symbol value */
+  Elf32_Word	st_size;		/* Symbol size */
+  unsigned char	st_info;		/* Symbol type and binding */
+  unsigned char	st_other;		/* Symbol visibility */
+  Elf32_Section	st_shndx;		/* Section index */
+} Elf32_Sym;
+
+typedef struct
+{
+  Elf64_Word	st_name;		/* Symbol name (string tbl index) */
+  unsigned char	st_info;		/* Symbol type and binding */
+  unsigned char st_other;		/* Symbol visibility */
+  Elf64_Section	st_shndx;		/* Section index */
+  Elf64_Addr	st_value;		/* Symbol value */
+  Elf64_Xword	st_size;		/* Symbol size */
+} Elf64_Sym;
+
+/* The syminfo section if available contains additional information about
+   every dynamic symbol.  */
+
+typedef struct
+{
+  Elf32_Half si_boundto;		/* Direct bindings, symbol bound to */
+  Elf32_Half si_flags;			/* Per symbol flags */
+} Elf32_Syminfo;
+
+typedef struct
+{
+  Elf64_Half si_boundto;		/* Direct bindings, symbol bound to */
+  Elf64_Half si_flags;			/* Per symbol flags */
+} Elf64_Syminfo;
+
+/* Possible values for si_boundto.  */
+#define SYMINFO_BT_SELF		0xffff	/* Symbol bound to self */
+#define SYMINFO_BT_PARENT	0xfffe	/* Symbol bound to parent */
+#define SYMINFO_BT_LOWRESERVE	0xff00	/* Beginning of reserved entries */
+
+/* Possible bitmasks for si_flags.  */
+#define SYMINFO_FLG_DIRECT	0x0001	/* Direct bound symbol */
+#define SYMINFO_FLG_PASSTHRU	0x0002	/* Pass-thru symbol for translator */
+#define SYMINFO_FLG_COPY	0x0004	/* Symbol is a copy-reloc */
+#define SYMINFO_FLG_LAZYLOAD	0x0008	/* Symbol bound to object to be lazy
+					   loaded */
+/* Syminfo version values.  */
+#define SYMINFO_NONE		0
+#define SYMINFO_CURRENT		1
+#define SYMINFO_NUM		2
+
+
+/* How to extract and insert information held in the st_info field.  */
+
+#define ELF32_ST_BIND(val)		(((unsigned char) (val)) >> 4)
+#define ELF32_ST_TYPE(val)		((val) & 0xf)
+#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))
+
+/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */
+#define ELF64_ST_BIND(val)		ELF32_ST_BIND (val)
+#define ELF64_ST_TYPE(val)		ELF32_ST_TYPE (val)
+#define ELF64_ST_INFO(bind, type)	ELF32_ST_INFO ((bind), (type))
+
+/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
+
+#define STB_LOCAL	0		/* Local symbol */
+#define STB_GLOBAL	1		/* Global symbol */
+#define STB_WEAK	2		/* Weak symbol */
+#define	STB_NUM		3		/* Number of defined types.  */
+#define STB_LOOS	10		/* Start of OS-specific */
+#define STB_HIOS	12		/* End of OS-specific */
+#define STB_LOPROC	13		/* Start of processor-specific */
+#define STB_HIPROC	15		/* End of processor-specific */
+
+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
+
+#define STT_NOTYPE	0		/* Symbol type is unspecified */
+#define STT_OBJECT	1		/* Symbol is a data object */
+#define STT_FUNC	2		/* Symbol is a code object */
+#define STT_SECTION	3		/* Symbol associated with a section */
+#define STT_FILE	4		/* Symbol's name is file name */
+#define STT_COMMON	5		/* Symbol is a common data object */
+#define STT_TLS		6		/* Symbol is thread-local data object*/
+#define	STT_NUM		7		/* Number of defined types.  */
+#define STT_LOOS	10		/* Start of OS-specific */
+#define STT_HIOS	12		/* End of OS-specific */
+#define STT_LOPROC	13		/* Start of processor-specific */
+#define STT_HIPROC	15		/* End of processor-specific */
+
+
+/* Symbol table indices are found in the hash buckets and chain table
+   of a symbol hash table section.  This special index value indicates
+   the end of a chain, meaning no further symbols are found in that bucket.  */
+
+#define STN_UNDEF	0		/* End of a chain.  */
+
+
+/* How to extract and insert information held in the st_other field.  */
+
+#define ELF32_ST_VISIBILITY(o)	((o) & 0x03)
+
+/* For ELF64 the definitions are the same.  */
+#define ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)
+
+/* Symbol visibility specification encoded in the st_other field.  */
+#define STV_DEFAULT	0		/* Default symbol visibility rules */
+#define STV_INTERNAL	1		/* Processor specific hidden class */
+#define STV_HIDDEN	2		/* Sym unavailable in other modules */
+#define STV_PROTECTED	3		/* Not preemptible, not exported */
+
+
+/* Relocation table entry without addend (in section of type SHT_REL).  */
+
+typedef struct
+{
+  Elf32_Addr	r_offset;		/* Address */
+  Elf32_Word	r_info;			/* Relocation type and symbol index */
+} Elf32_Rel;
+
+/* I have seen two different definitions of the Elf64_Rel and
+   Elf64_Rela structures, so we'll leave them out until Novell (or
+   whoever) gets their act together.  */
+/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
+
+typedef struct
+{
+  Elf64_Addr	r_offset;		/* Address */
+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
+} Elf64_Rel;
+
+/* Relocation table entry with addend (in section of type SHT_RELA).  */
+
+typedef struct
+{
+  Elf32_Addr	r_offset;		/* Address */
+  Elf32_Word	r_info;			/* Relocation type and symbol index */
+  Elf32_Sword	r_addend;		/* Addend */
+} Elf32_Rela;
+
+typedef struct
+{
+  Elf64_Addr	r_offset;		/* Address */
+  Elf64_Xword	r_info;			/* Relocation type and symbol index */
+  Elf64_Sxword	r_addend;		/* Addend */
+} Elf64_Rela;
+
+/* How to extract and insert information held in the r_info field.  */
+
+#define ELF32_R_SYM(val)		((val) >> 8)
+#define ELF32_R_TYPE(val)		((val) & 0xff)
+#define ELF32_R_INFO(sym, type)		(((sym) << 8) + ((type) & 0xff))
+
+#define ELF64_R_SYM(i)			((i) >> 32)
+#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
+#define ELF64_R_INFO(sym,type)		((((Elf64_Xword) (sym)) << 32) + (type))
+
+/* Program segment header.  */
+
+typedef struct
+{
+  Elf32_Word	p_type;			/* Segment type */
+  Elf32_Off	p_offset;		/* Segment file offset */
+  Elf32_Addr	p_vaddr;		/* Segment virtual address */
+  Elf32_Addr	p_paddr;		/* Segment physical address */
+  Elf32_Word	p_filesz;		/* Segment size in file */
+  Elf32_Word	p_memsz;		/* Segment size in memory */
+  Elf32_Word	p_flags;		/* Segment flags */
+  Elf32_Word	p_align;		/* Segment alignment */
+} Elf32_Phdr;
+
+typedef struct
+{
+  Elf64_Word	p_type;			/* Segment type */
+  Elf64_Word	p_flags;		/* Segment flags */
+  Elf64_Off	p_offset;		/* Segment file offset */
+  Elf64_Addr	p_vaddr;		/* Segment virtual address */
+  Elf64_Addr	p_paddr;		/* Segment physical address */
+  Elf64_Xword	p_filesz;		/* Segment size in file */
+  Elf64_Xword	p_memsz;		/* Segment size in memory */
+  Elf64_Xword	p_align;		/* Segment alignment */
+} Elf64_Phdr;
+
+/* Legal values for p_type (segment type).  */
+
+#define	PT_NULL		0		/* Program header table entry unused */
+#define PT_LOAD		1		/* Loadable program segment */
+#define PT_DYNAMIC	2		/* Dynamic linking information */
+#define PT_INTERP	3		/* Program interpreter */
+#define PT_NOTE		4		/* Auxiliary information */
+#define PT_SHLIB	5		/* Reserved */
+#define PT_PHDR		6		/* Entry for header table itself */
+#define PT_TLS		7		/* Thread-local storage segment */
+#define	PT_NUM		8		/* Number of defined types */
+#define PT_LOOS		0x60000000	/* Start of OS-specific */
+#define PT_GNU_EH_FRAME	0x6474e550	/* GCC .eh_frame_hdr segment */
+#define PT_GNU_STACK	0x6474e551	/* Indicates stack executability */
+#define PT_GNU_RELRO	0x6474e552	/* Read-only after relocation */
+#define PT_LOSUNW	0x6ffffffa
+#define PT_SUNWBSS	0x6ffffffa	/* Sun Specific segment */
+#define PT_SUNWSTACK	0x6ffffffb	/* Stack segment */
+#define PT_HISUNW	0x6fffffff
+#define PT_HIOS		0x6fffffff	/* End of OS-specific */
+#define PT_LOPROC	0x70000000	/* Start of processor-specific */
+#define PT_HIPROC	0x7fffffff	/* End of processor-specific */
+
+/* Legal values for p_flags (segment flags).  */
+
+#define PF_X		(1 << 0)	/* Segment is executable */
+#define PF_W		(1 << 1)	/* Segment is writable */
+#define PF_R		(1 << 2)	/* Segment is readable */
+#define PF_MASKOS	0x0ff00000	/* OS-specific */
+#define PF_MASKPROC	0xf0000000	/* Processor-specific */
+
+/* Legal values for note segment descriptor types for core files. */
+
+#define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
+#define NT_FPREGSET	2		/* Contains copy of fpregset struct */
+#define NT_PRPSINFO	3		/* Contains copy of prpsinfo struct */
+#define NT_PRXREG	4		/* Contains copy of prxregset struct */
+#define NT_TASKSTRUCT	4		/* Contains copy of task structure */
+#define NT_PLATFORM	5		/* String from sysinfo(SI_PLATFORM) */
+#define NT_AUXV		6		/* Contains copy of auxv array */
+#define NT_GWINDOWS	7		/* Contains copy of gwindows struct */
+#define NT_ASRS		8		/* Contains copy of asrset struct */
+#define NT_PSTATUS	10		/* Contains copy of pstatus struct */
+#define NT_PSINFO	13		/* Contains copy of psinfo struct */
+#define NT_PRCRED	14		/* Contains copy of prcred struct */
+#define NT_UTSNAME	15		/* Contains copy of utsname struct */
+#define NT_LWPSTATUS	16		/* Contains copy of lwpstatus struct */
+#define NT_LWPSINFO	17		/* Contains copy of lwpinfo struct */
+#define NT_PRFPXREG	20		/* Contains copy of fprxregset struct*/
+
+/* Legal values for the note segment descriptor types for object files.  */
+
+#define NT_VERSION	1		/* Contains a version string.  */
+
+
+/* Dynamic section entry.  */
+
+typedef struct
+{
+  Elf32_Sword	d_tag;			/* Dynamic entry type */
+  union
+    {
+      Elf32_Word d_val;			/* Integer value */
+      Elf32_Addr d_ptr;			/* Address value */
+    } d_un;
+} Elf32_Dyn;
+
+typedef struct
+{
+  Elf64_Sxword	d_tag;			/* Dynamic entry type */
+  union
+    {
+      Elf64_Xword d_val;		/* Integer value */
+      Elf64_Addr d_ptr;			/* Address value */
+    } d_un;
+} Elf64_Dyn;
+
+/* Legal values for d_tag (dynamic entry type).  */
+
+#define DT_NULL		0		/* Marks end of dynamic section */
+#define DT_NEEDED	1		/* Name of needed library */
+#define DT_PLTRELSZ	2		/* Size in bytes of PLT relocs */
+#define DT_PLTGOT	3		/* Processor defined value */
+#define DT_HASH		4		/* Address of symbol hash table */
+#define DT_STRTAB	5		/* Address of string table */
+#define DT_SYMTAB	6		/* Address of symbol table */
+#define DT_RELA		7		/* Address of Rela relocs */
+#define DT_RELASZ	8		/* Total size of Rela relocs */
+#define DT_RELAENT	9		/* Size of one Rela reloc */
+#define DT_STRSZ	10		/* Size of string table */
+#define DT_SYMENT	11		/* Size of one symbol table entry */
+#define DT_INIT		12		/* Address of init function */
+#define DT_FINI		13		/* Address of termination function */
+#define DT_SONAME	14		/* Name of shared object */
+#define DT_RPATH	15		/* Library search path (deprecated) */
+#define DT_SYMBOLIC	16		/* Start symbol search here */
+#define DT_REL		17		/* Address of Rel relocs */
+#define DT_RELSZ	18		/* Total size of Rel relocs */
+#define DT_RELENT	19		/* Size of one Rel reloc */
+#define DT_PLTREL	20		/* Type of reloc in PLT */
+#define DT_DEBUG	21		/* For debugging; unspecified */
+#define DT_TEXTREL	22		/* Reloc might modify .text */
+#define DT_JMPREL	23		/* Address of PLT relocs */
+#define	DT_BIND_NOW	24		/* Process relocations of object */
+#define	DT_INIT_ARRAY	25		/* Array with addresses of init fct */
+#define	DT_FINI_ARRAY	26		/* Array with addresses of fini fct */
+#define	DT_INIT_ARRAYSZ	27		/* Size in bytes of DT_INIT_ARRAY */
+#define	DT_FINI_ARRAYSZ	28		/* Size in bytes of DT_FINI_ARRAY */
+#define DT_RUNPATH	29		/* Library search path */
+#define DT_FLAGS	30		/* Flags for the object being loaded */
+#define DT_ENCODING	32		/* Start of encoded range */
+#define DT_PREINIT_ARRAY 32		/* Array with addresses of preinit fct*/
+#define DT_PREINIT_ARRAYSZ 33		/* size in bytes of DT_PREINIT_ARRAY */
+#define	DT_NUM		34		/* Number used */
+#define DT_LOOS		0x6000000d	/* Start of OS-specific */
+#define DT_HIOS		0x6ffff000	/* End of OS-specific */
+#define DT_LOPROC	0x70000000	/* Start of processor-specific */
+#define DT_HIPROC	0x7fffffff	/* End of processor-specific */
+#define	DT_PROCNUM	DT_MIPS_NUM	/* Most used by any processor */
+
+/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
+   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
+   approach.  */
+#define DT_VALRNGLO	0x6ffffd00
+#define DT_GNU_PRELINKED 0x6ffffdf5	/* Prelinking timestamp */
+#define DT_GNU_CONFLICTSZ 0x6ffffdf6	/* Size of conflict section */
+#define DT_GNU_LIBLISTSZ 0x6ffffdf7	/* Size of library list */
+#define DT_CHECKSUM	0x6ffffdf8
+#define DT_PLTPADSZ	0x6ffffdf9
+#define DT_MOVEENT	0x6ffffdfa
+#define DT_MOVESZ	0x6ffffdfb
+#define DT_FEATURE_1	0x6ffffdfc	/* Feature selection (DTF_*).  */
+#define DT_POSFLAG_1	0x6ffffdfd	/* Flags for DT_* entries, effecting
+					   the following DT_* entry.  */
+#define DT_SYMINSZ	0x6ffffdfe	/* Size of syminfo table (in bytes) */
+#define DT_SYMINENT	0x6ffffdff	/* Entry size of syminfo */
+#define DT_VALRNGHI	0x6ffffdff
+#define DT_VALTAGIDX(tag)	(DT_VALRNGHI - (tag))	/* Reverse order! */
+#define DT_VALNUM 12
+
+/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
+   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.
+
+   If any adjustment is made to the ELF object after it has been
+   built these entries will need to be adjusted.  */
+#define DT_ADDRRNGLO	0x6ffffe00
+#define DT_GNU_CONFLICT	0x6ffffef8	/* Start of conflict section */
+#define DT_GNU_LIBLIST	0x6ffffef9	/* Library list */
+#define DT_CONFIG	0x6ffffefa	/* Configuration information.  */
+#define DT_DEPAUDIT	0x6ffffefb	/* Dependency auditing.  */
+#define DT_AUDIT	0x6ffffefc	/* Object auditing.  */
+#define	DT_PLTPAD	0x6ffffefd	/* PLT padding.  */
+#define	DT_MOVETAB	0x6ffffefe	/* Move table.  */
+#define DT_SYMINFO	0x6ffffeff	/* Syminfo table.  */
+#define DT_ADDRRNGHI	0x6ffffeff
+#define DT_ADDRTAGIDX(tag)	(DT_ADDRRNGHI - (tag))	/* Reverse order! */
+#define DT_ADDRNUM 10
+
+/* The versioning entry types.  The next are defined as part of the
+   GNU extension.  */
+#define DT_VERSYM	0x6ffffff0
+
+#define DT_RELACOUNT	0x6ffffff9
+#define DT_RELCOUNT	0x6ffffffa
+
+/* These were chosen by Sun.  */
+#define DT_FLAGS_1	0x6ffffffb	/* State flags, see DF_1_* below.  */
+#define	DT_VERDEF	0x6ffffffc	/* Address of version definition
+					   table */
+#define	DT_VERDEFNUM	0x6ffffffd	/* Number of version definitions */
+#define	DT_VERNEED	0x6ffffffe	/* Address of table with needed
+					   versions */
+#define	DT_VERNEEDNUM	0x6fffffff	/* Number of needed versions */
+#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
+#define DT_VERSIONTAGNUM 16
+
+/* Sun added these machine-independent extensions in the "processor-specific"
+   range.  Be compatible.  */
+#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */
+#define DT_FILTER       0x7fffffff      /* Shared object to get values from */
+#define DT_EXTRATAGIDX(tag)	((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
+#define DT_EXTRANUM	3
+
+/* Values of `d_un.d_val' in the DT_FLAGS entry.  */
+#define DF_ORIGIN	0x00000001	/* Object may use DF_ORIGIN */
+#define DF_SYMBOLIC	0x00000002	/* Symbol resolutions starts here */
+#define DF_TEXTREL	0x00000004	/* Object contains text relocations */
+#define DF_BIND_NOW	0x00000008	/* No lazy binding for this object */
+#define DF_STATIC_TLS	0x00000010	/* Module uses the static TLS model */
+
+/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1
+   entry in the dynamic section.  */
+#define DF_1_NOW	0x00000001	/* Set RTLD_NOW for this object.  */
+#define DF_1_GLOBAL	0x00000002	/* Set RTLD_GLOBAL for this object.  */
+#define DF_1_GROUP	0x00000004	/* Set RTLD_GROUP for this object.  */
+#define DF_1_NODELETE	0x00000008	/* Set RTLD_NODELETE for this object.*/
+#define DF_1_LOADFLTR	0x00000010	/* Trigger filtee loading at runtime.*/
+#define DF_1_INITFIRST	0x00000020	/* Set RTLD_INITFIRST for this object*/
+#define DF_1_NOOPEN	0x00000040	/* Set RTLD_NOOPEN for this object.  */
+#define DF_1_ORIGIN	0x00000080	/* $ORIGIN must be handled.  */
+#define DF_1_DIRECT	0x00000100	/* Direct binding enabled.  */
+#define DF_1_TRANS	0x00000200
+#define DF_1_INTERPOSE	0x00000400	/* Object is used to interpose.  */
+#define DF_1_NODEFLIB	0x00000800	/* Ignore default lib search path.  */
+#define DF_1_NODUMP	0x00001000	/* Object can't be dldump'ed.  */
+#define DF_1_CONFALT	0x00002000	/* Configuration alternative created.*/
+#define DF_1_ENDFILTEE	0x00004000	/* Filtee terminates filters search. */
+#define	DF_1_DISPRELDNE	0x00008000	/* Disp reloc applied at build time. */
+#define	DF_1_DISPRELPND	0x00010000	/* Disp reloc applied at run-time.  */
+
+/* Flags for the feature selection in DT_FEATURE_1.  */
+#define DTF_1_PARINIT	0x00000001
+#define DTF_1_CONFEXP	0x00000002
+
+/* Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry.  */
+#define DF_P1_LAZYLOAD	0x00000001	/* Lazyload following object.  */
+#define DF_P1_GROUPPERM	0x00000002	/* Symbols from next object are not
+					   generally available.  */
+
+/* Version definition sections.  */
+
+typedef struct
+{
+  Elf32_Half	vd_version;		/* Version revision */
+  Elf32_Half	vd_flags;		/* Version information */
+  Elf32_Half	vd_ndx;			/* Version Index */
+  Elf32_Half	vd_cnt;			/* Number of associated aux entries */
+  Elf32_Word	vd_hash;		/* Version name hash value */
+  Elf32_Word	vd_aux;			/* Offset in bytes to verdaux array */
+  Elf32_Word	vd_next;		/* Offset in bytes to next verdef
+					   entry */
+} Elf32_Verdef;
+
+typedef struct
+{
+  Elf64_Half	vd_version;		/* Version revision */
+  Elf64_Half	vd_flags;		/* Version information */
+  Elf64_Half	vd_ndx;			/* Version Index */
+  Elf64_Half	vd_cnt;			/* Number of associated aux entries */
+  Elf64_Word	vd_hash;		/* Version name hash value */
+  Elf64_Word	vd_aux;			/* Offset in bytes to verdaux array */
+  Elf64_Word	vd_next;		/* Offset in bytes to next verdef
+					   entry */
+} Elf64_Verdef;
+
+
+/* Legal values for vd_version (version revision).  */
+#define VER_DEF_NONE	0		/* No version */
+#define VER_DEF_CURRENT	1		/* Current version */
+#define VER_DEF_NUM	2		/* Given version number */
+
+/* Legal values for vd_flags (version information flags).  */
+#define VER_FLG_BASE	0x1		/* Version definition of file itself */
+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
+
+/* Versym symbol index values.  */
+#define	VER_NDX_LOCAL		0	/* Symbol is local.  */
+#define	VER_NDX_GLOBAL		1	/* Symbol is global.  */
+#define	VER_NDX_LORESERVE	0xff00	/* Beginning of reserved entries.  */
+#define	VER_NDX_ELIMINATE	0xff01	/* Symbol is to be eliminated.  */
+
+/* Auxialiary version information.  */
+
+typedef struct
+{
+  Elf32_Word	vda_name;		/* Version or dependency names */
+  Elf32_Word	vda_next;		/* Offset in bytes to next verdaux
+					   entry */
+} Elf32_Verdaux;
+
+typedef struct
+{
+  Elf64_Word	vda_name;		/* Version or dependency names */
+  Elf64_Word	vda_next;		/* Offset in bytes to next verdaux
+					   entry */
+} Elf64_Verdaux;
+
+
+/* Version dependency section.  */
+
+typedef struct
+{
+  Elf32_Half	vn_version;		/* Version of structure */
+  Elf32_Half	vn_cnt;			/* Number of associated aux entries */
+  Elf32_Word	vn_file;		/* Offset of filename for this
+					   dependency */
+  Elf32_Word	vn_aux;			/* Offset in bytes to vernaux array */
+  Elf32_Word	vn_next;		/* Offset in bytes to next verneed
+					   entry */
+} Elf32_Verneed;
+
+typedef struct
+{
+  Elf64_Half	vn_version;		/* Version of structure */
+  Elf64_Half	vn_cnt;			/* Number of associated aux entries */
+  Elf64_Word	vn_file;		/* Offset of filename for this
+					   dependency */
+  Elf64_Word	vn_aux;			/* Offset in bytes to vernaux array */
+  Elf64_Word	vn_next;		/* Offset in bytes to next verneed
+					   entry */
+} Elf64_Verneed;
+
+
+/* Legal values for vn_version (version revision).  */
+#define VER_NEED_NONE	 0		/* No version */
+#define VER_NEED_CURRENT 1		/* Current version */
+#define VER_NEED_NUM	 2		/* Given version number */
+
+/* Auxiliary needed version information.  */
+
+typedef struct
+{
+  Elf32_Word	vna_hash;		/* Hash value of dependency name */
+  Elf32_Half	vna_flags;		/* Dependency specific information */
+  Elf32_Half	vna_other;		/* Unused */
+  Elf32_Word	vna_name;		/* Dependency name string offset */
+  Elf32_Word	vna_next;		/* Offset in bytes to next vernaux
+					   entry */
+} Elf32_Vernaux;
+
+typedef struct
+{
+  Elf64_Word	vna_hash;		/* Hash value of dependency name */
+  Elf64_Half	vna_flags;		/* Dependency specific information */
+  Elf64_Half	vna_other;		/* Unused */
+  Elf64_Word	vna_name;		/* Dependency name string offset */
+  Elf64_Word	vna_next;		/* Offset in bytes to next vernaux
+					   entry */
+} Elf64_Vernaux;
+
+
+/* Legal values for vna_flags.  */
+#define VER_FLG_WEAK	0x2		/* Weak version identifier */
+
+
+/* Auxiliary vector.  */
+
+/* This vector is normally only used by the program interpreter.  The
+   usual definition in an ABI supplement uses the name auxv_t.  The
+   vector is not usually defined in a standard <elf.h> file, but it
+   can't hurt.  We rename it to avoid conflicts.  The sizes of these
+   types are an arrangement between the exec server and the program
+   interpreter, so we don't fully specify them here.  */
+
+typedef struct
+{
+  int a_type;			/* Entry type */
+  union
+    {
+      long int a_val;		/* Integer value */
+      void *a_ptr;		/* Pointer value */
+      void (*a_fcn) (void);	/* Function pointer value */
+    } a_un;
+} Elf32_auxv_t;
+
+typedef struct
+{
+  long int a_type;		/* Entry type */
+  union
+    {
+      long int a_val;		/* Integer value */
+      void *a_ptr;		/* Pointer value */
+      void (*a_fcn) (void);	/* Function pointer value */
+    } a_un;
+} Elf64_auxv_t;
+
+/* Legal values for a_type (entry type).  */
+
+#define AT_NULL		0		/* End of vector */
+#define AT_IGNORE	1		/* Entry should be ignored */
+#define AT_EXECFD	2		/* File descriptor of program */
+#define AT_PHDR		3		/* Program headers for program */
+#define AT_PHENT	4		/* Size of program header entry */
+#define AT_PHNUM	5		/* Number of program headers */
+#define AT_PAGESZ	6		/* System page size */
+#define AT_BASE		7		/* Base address of interpreter */
+#define AT_FLAGS	8		/* Flags */
+#define AT_ENTRY	9		/* Entry point of program */
+#define AT_NOTELF	10		/* Program is not ELF */
+#define AT_UID		11		/* Real uid */
+#define AT_EUID		12		/* Effective uid */
+#define AT_GID		13		/* Real gid */
+#define AT_EGID		14		/* Effective gid */
+#define AT_CLKTCK	17		/* Frequency of times() */
+
+/* Some more special a_type values describing the hardware.  */
+#define AT_PLATFORM	15		/* String identifying platform.  */
+#define AT_HWCAP	16		/* Machine dependent hints about
+					   processor capabilities.  */
+
+/* This entry gives some information about the FPU initialization
+   performed by the kernel.  */
+#define AT_FPUCW	18		/* Used FPU control word.  */
+
+/* Cache block sizes.  */
+#define AT_DCACHEBSIZE	19		/* Data cache block size.  */
+#define AT_ICACHEBSIZE	20		/* Instruction cache block size.  */
+#define AT_UCACHEBSIZE	21		/* Unified cache block size.  */
+
+/* A special ignored value for PPC, used by the kernel to control the
+   interpretation of the AUXV. Must be > 16.  */
+#define AT_IGNOREPPC	22		/* Entry should be ignored.  */
+
+#define	AT_SECURE	23		/* Boolean, was exec setuid-like?  */
+
+/* Pointer to the global system page used for system calls and other
+   nice things.  */
+#define AT_SYSINFO	32
+#define AT_SYSINFO_EHDR	33
+
+/* Shapes of the caches.  Bits 0-3 contains associativity; bits 4-7 contains
+   log2 of line size; mask those to get cache size.  */
+#define AT_L1I_CACHESHAPE	34
+#define AT_L1D_CACHESHAPE	35
+#define AT_L2_CACHESHAPE	36
+#define AT_L3_CACHESHAPE	37
+
+/* Note section contents.  Each entry in the note section begins with
+   a header of a fixed form.  */
+
+typedef struct
+{
+  Elf32_Word n_namesz;			/* Length of the note's name.  */
+  Elf32_Word n_descsz;			/* Length of the note's descriptor.  */
+  Elf32_Word n_type;			/* Type of the note.  */
+} Elf32_Nhdr;
+
+typedef struct
+{
+  Elf64_Word n_namesz;			/* Length of the note's name.  */
+  Elf64_Word n_descsz;			/* Length of the note's descriptor.  */
+  Elf64_Word n_type;			/* Type of the note.  */
+} Elf64_Nhdr;
+
+/* Known names of notes.  */
+
+/* Solaris entries in the note section have this name.  */
+#define ELF_NOTE_SOLARIS	"SUNW Solaris"
+
+/* Note entries for GNU systems have this name.  */
+#define ELF_NOTE_GNU		"GNU"
+
+
+/* Defined types of notes for Solaris.  */
+
+/* Value of descriptor (one word) is desired pagesize for the binary.  */
+#define ELF_NOTE_PAGESIZE_HINT	1
+
+
+/* Defined note types for GNU systems.  */
+
+/* ABI information.  The descriptor consists of words:
+   word 0: OS descriptor
+   word 1: major version of the ABI
+   word 2: minor version of the ABI
+   word 3: subminor version of the ABI
+*/
+#define ELF_NOTE_ABI		1
+
+/* Known OSes.  These value can appear in word 0 of an ELF_NOTE_ABI
+   note section entry.  */
+#define ELF_NOTE_OS_LINUX	0
+#define ELF_NOTE_OS_GNU		1
+#define ELF_NOTE_OS_SOLARIS2	2
+#define ELF_NOTE_OS_FREEBSD	3
+
+
+/* Move records.  */
+typedef struct
+{
+  Elf32_Xword m_value;		/* Symbol value.  */
+  Elf32_Word m_info;		/* Size and index.  */
+  Elf32_Word m_poffset;		/* Symbol offset.  */
+  Elf32_Half m_repeat;		/* Repeat count.  */
+  Elf32_Half m_stride;		/* Stride info.  */
+} Elf32_Move;
+
+typedef struct
+{
+  Elf64_Xword m_value;		/* Symbol value.  */
+  Elf64_Xword m_info;		/* Size and index.  */
+  Elf64_Xword m_poffset;	/* Symbol offset.  */
+  Elf64_Half m_repeat;		/* Repeat count.  */
+  Elf64_Half m_stride;		/* Stride info.  */
+} Elf64_Move;
+
+/* Macro to construct move records.  */
+#define ELF32_M_SYM(info)	((info) >> 8)
+#define ELF32_M_SIZE(info)	((unsigned char) (info))
+#define ELF32_M_INFO(sym, size)	(((sym) << 8) + (unsigned char) (size))
+
+#define ELF64_M_SYM(info)	ELF32_M_SYM (info)
+#define ELF64_M_SIZE(info)	ELF32_M_SIZE (info)
+#define ELF64_M_INFO(sym, size)	ELF32_M_INFO (sym, size)
+
+
+/* Motorola 68k specific definitions.  */
+
+/* Values for Elf32_Ehdr.e_flags.  */
+#define EF_CPU32	0x00810000
+
+/* m68k relocs.  */
+
+#define R_68K_NONE	0		/* No reloc */
+#define R_68K_32	1		/* Direct 32 bit  */
+#define R_68K_16	2		/* Direct 16 bit  */
+#define R_68K_8		3		/* Direct 8 bit  */
+#define R_68K_PC32	4		/* PC relative 32 bit */
+#define R_68K_PC16	5		/* PC relative 16 bit */
+#define R_68K_PC8	6		/* PC relative 8 bit */
+#define R_68K_GOT32	7		/* 32 bit PC relative GOT entry */
+#define R_68K_GOT16	8		/* 16 bit PC relative GOT entry */
+#define R_68K_GOT8	9		/* 8 bit PC relative GOT entry */
+#define R_68K_GOT32O	10		/* 32 bit GOT offset */
+#define R_68K_GOT16O	11		/* 16 bit GOT offset */
+#define R_68K_GOT8O	12		/* 8 bit GOT offset */
+#define R_68K_PLT32	13		/* 32 bit PC relative PLT address */
+#define R_68K_PLT16	14		/* 16 bit PC relative PLT address */
+#define R_68K_PLT8	15		/* 8 bit PC relative PLT address */
+#define R_68K_PLT32O	16		/* 32 bit PLT offset */
+#define R_68K_PLT16O	17		/* 16 bit PLT offset */
+#define R_68K_PLT8O	18		/* 8 bit PLT offset */
+#define R_68K_COPY	19		/* Copy symbol at runtime */
+#define R_68K_GLOB_DAT	20		/* Create GOT entry */
+#define R_68K_JMP_SLOT	21		/* Create PLT entry */
+#define R_68K_RELATIVE	22		/* Adjust by program base */
+/* Keep this the last entry.  */
+#define R_68K_NUM	23
+
+/* Intel 80386 specific definitions.  */
+
+/* i386 relocs.  */
+
+#define R_386_NONE	   0		/* No reloc */
+#define R_386_32	   1		/* Direct 32 bit  */
+#define R_386_PC32	   2		/* PC relative 32 bit */
+#define R_386_GOT32	   3		/* 32 bit GOT entry */
+#define R_386_PLT32	   4		/* 32 bit PLT address */
+#define R_386_COPY	   5		/* Copy symbol at runtime */
+#define R_386_GLOB_DAT	   6		/* Create GOT entry */
+#define R_386_JMP_SLOT	   7		/* Create PLT entry */
+#define R_386_RELATIVE	   8		/* Adjust by program base */
+#define R_386_GOTOFF	   9		/* 32 bit offset to GOT */
+#define R_386_GOTPC	   10		/* 32 bit PC relative offset to GOT */
+#define R_386_32PLT	   11
+#define R_386_TLS_TPOFF	   14		/* Offset in static TLS block */
+#define R_386_TLS_IE	   15		/* Address of GOT entry for static TLS
+					   block offset */
+#define R_386_TLS_GOTIE	   16		/* GOT entry for static TLS block
+					   offset */
+#define R_386_TLS_LE	   17		/* Offset relative to static TLS
+					   block */
+#define R_386_TLS_GD	   18		/* Direct 32 bit for GNU version of
+					   general dynamic thread local data */
+#define R_386_TLS_LDM	   19		/* Direct 32 bit for GNU version of
+					   local dynamic thread local data
+					   in LE code */
+#define R_386_16	   20
+#define R_386_PC16	   21
+#define R_386_8		   22
+#define R_386_PC8	   23
+#define R_386_TLS_GD_32	   24		/* Direct 32 bit for general dynamic
+					   thread local data */
+#define R_386_TLS_GD_PUSH  25		/* Tag for pushl in GD TLS code */
+#define R_386_TLS_GD_CALL  26		/* Relocation for call to
+					   __tls_get_addr() */
+#define R_386_TLS_GD_POP   27		/* Tag for popl in GD TLS code */
+#define R_386_TLS_LDM_32   28		/* Direct 32 bit for local dynamic
+					   thread local data in LE code */
+#define R_386_TLS_LDM_PUSH 29		/* Tag for pushl in LDM TLS code */
+#define R_386_TLS_LDM_CALL 30		/* Relocation for call to
+					   __tls_get_addr() in LDM code */
+#define R_386_TLS_LDM_POP  31		/* Tag for popl in LDM TLS code */
+#define R_386_TLS_LDO_32   32		/* Offset relative to TLS block */
+#define R_386_TLS_IE_32	   33		/* GOT entry for negated static TLS
+					   block offset */
+#define R_386_TLS_LE_32	   34		/* Negated offset relative to static
+					   TLS block */
+#define R_386_TLS_DTPMOD32 35		/* ID of module containing symbol */
+#define R_386_TLS_DTPOFF32 36		/* Offset in TLS block */
+#define R_386_TLS_TPOFF32  37		/* Negated offset in static TLS block */
+/* Keep this the last entry.  */
+#define R_386_NUM	   38
+
+/* SUN SPARC specific definitions.  */
+
+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
+
+#define STT_SPARC_REGISTER	13	/* Global register reserved to app. */
+
+/* Values for Elf64_Ehdr.e_flags.  */
+
+#define EF_SPARCV9_MM		3
+#define EF_SPARCV9_TSO		0
+#define EF_SPARCV9_PSO		1
+#define EF_SPARCV9_RMO		2
+#define EF_SPARC_LEDATA		0x800000 /* little endian data */
+#define EF_SPARC_EXT_MASK	0xFFFF00
+#define EF_SPARC_32PLUS		0x000100 /* generic V8+ features */
+#define EF_SPARC_SUN_US1	0x000200 /* Sun UltraSPARC1 extensions */
+#define EF_SPARC_HAL_R1		0x000400 /* HAL R1 extensions */
+#define EF_SPARC_SUN_US3	0x000800 /* Sun UltraSPARCIII extensions */
+
+/* SPARC relocs.  */
+
+#define R_SPARC_NONE		0	/* No reloc */
+#define R_SPARC_8		1	/* Direct 8 bit */
+#define R_SPARC_16		2	/* Direct 16 bit */
+#define R_SPARC_32		3	/* Direct 32 bit */
+#define R_SPARC_DISP8		4	/* PC relative 8 bit */
+#define R_SPARC_DISP16		5	/* PC relative 16 bit */
+#define R_SPARC_DISP32		6	/* PC relative 32 bit */
+#define R_SPARC_WDISP30		7	/* PC relative 30 bit shifted */
+#define R_SPARC_WDISP22		8	/* PC relative 22 bit shifted */
+#define R_SPARC_HI22		9	/* High 22 bit */
+#define R_SPARC_22		10	/* Direct 22 bit */
+#define R_SPARC_13		11	/* Direct 13 bit */
+#define R_SPARC_LO10		12	/* Truncated 10 bit */
+#define R_SPARC_GOT10		13	/* Truncated 10 bit GOT entry */
+#define R_SPARC_GOT13		14	/* 13 bit GOT entry */
+#define R_SPARC_GOT22		15	/* 22 bit GOT entry shifted */
+#define R_SPARC_PC10		16	/* PC relative 10 bit truncated */
+#define R_SPARC_PC22		17	/* PC relative 22 bit shifted */
+#define R_SPARC_WPLT30		18	/* 30 bit PC relative PLT address */
+#define R_SPARC_COPY		19	/* Copy symbol at runtime */
+#define R_SPARC_GLOB_DAT	20	/* Create GOT entry */
+#define R_SPARC_JMP_SLOT	21	/* Create PLT entry */
+#define R_SPARC_RELATIVE	22	/* Adjust by program base */
+#define R_SPARC_UA32		23	/* Direct 32 bit unaligned */
+
+/* Additional Sparc64 relocs.  */
+
+#define R_SPARC_PLT32		24	/* Direct 32 bit ref to PLT entry */
+#define R_SPARC_HIPLT22		25	/* High 22 bit PLT entry */
+#define R_SPARC_LOPLT10		26	/* Truncated 10 bit PLT entry */
+#define R_SPARC_PCPLT32		27	/* PC rel 32 bit ref to PLT entry */
+#define R_SPARC_PCPLT22		28	/* PC rel high 22 bit PLT entry */
+#define R_SPARC_PCPLT10		29	/* PC rel trunc 10 bit PLT entry */
+#define R_SPARC_10		30	/* Direct 10 bit */
+#define R_SPARC_11		31	/* Direct 11 bit */
+#define R_SPARC_64		32	/* Direct 64 bit */
+#define R_SPARC_OLO10		33	/* 10bit with secondary 13bit addend */
+#define R_SPARC_HH22		34	/* Top 22 bits of direct 64 bit */
+#define R_SPARC_HM10		35	/* High middle 10 bits of ... */
+#define R_SPARC_LM22		36	/* Low middle 22 bits of ... */
+#define R_SPARC_PC_HH22		37	/* Top 22 bits of pc rel 64 bit */
+#define R_SPARC_PC_HM10		38	/* High middle 10 bit of ... */
+#define R_SPARC_PC_LM22		39	/* Low miggle 22 bits of ... */
+#define R_SPARC_WDISP16		40	/* PC relative 16 bit shifted */
+#define R_SPARC_WDISP19		41	/* PC relative 19 bit shifted */
+#define R_SPARC_7		43	/* Direct 7 bit */
+#define R_SPARC_5		44	/* Direct 5 bit */
+#define R_SPARC_6		45	/* Direct 6 bit */
+#define R_SPARC_DISP64		46	/* PC relative 64 bit */
+#define R_SPARC_PLT64		47	/* Direct 64 bit ref to PLT entry */
+#define R_SPARC_HIX22		48	/* High 22 bit complemented */
+#define R_SPARC_LOX10		49	/* Truncated 11 bit complemented */
+#define R_SPARC_H44		50	/* Direct high 12 of 44 bit */
+#define R_SPARC_M44		51	/* Direct mid 22 of 44 bit */
+#define R_SPARC_L44		52	/* Direct low 10 of 44 bit */
+#define R_SPARC_REGISTER	53	/* Global register usage */
+#define R_SPARC_UA64		54	/* Direct 64 bit unaligned */
+#define R_SPARC_UA16		55	/* Direct 16 bit unaligned */
+#define R_SPARC_TLS_GD_HI22	56
+#define R_SPARC_TLS_GD_LO10	57
+#define R_SPARC_TLS_GD_ADD	58
+#define R_SPARC_TLS_GD_CALL	59
+#define R_SPARC_TLS_LDM_HI22	60
+#define R_SPARC_TLS_LDM_LO10	61
+#define R_SPARC_TLS_LDM_ADD	62
+#define R_SPARC_TLS_LDM_CALL	63
+#define R_SPARC_TLS_LDO_HIX22	64
+#define R_SPARC_TLS_LDO_LOX10	65
+#define R_SPARC_TLS_LDO_ADD	66
+#define R_SPARC_TLS_IE_HI22	67
+#define R_SPARC_TLS_IE_LO10	68
+#define R_SPARC_TLS_IE_LD	69
+#define R_SPARC_TLS_IE_LDX	70
+#define R_SPARC_TLS_IE_ADD	71
+#define R_SPARC_TLS_LE_HIX22	72
+#define R_SPARC_TLS_LE_LOX10	73
+#define R_SPARC_TLS_DTPMOD32	74
+#define R_SPARC_TLS_DTPMOD64	75
+#define R_SPARC_TLS_DTPOFF32	76
+#define R_SPARC_TLS_DTPOFF64	77
+#define R_SPARC_TLS_TPOFF32	78
+#define R_SPARC_TLS_TPOFF64	79
+/* Keep this the last entry.  */
+#define R_SPARC_NUM		80
+
+/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */
+
+#define DT_SPARC_REGISTER 0x70000001
+#define DT_SPARC_NUM	2
+
+/* Bits present in AT_HWCAP, primarily for Sparc32.  */
+
+#define HWCAP_SPARC_FLUSH	1	/* The cpu supports flush insn.  */
+#define HWCAP_SPARC_STBAR	2
+#define HWCAP_SPARC_SWAP	4
+#define HWCAP_SPARC_MULDIV	8
+#define HWCAP_SPARC_V9		16	/* The cpu is v9, so v8plus is ok.  */
+#define HWCAP_SPARC_ULTRA3	32
+
+/* MIPS R3000 specific definitions.  */
+
+/* Legal values for e_flags field of Elf32_Ehdr.  */
+
+#define EF_MIPS_NOREORDER   1		/* A .noreorder directive was used */
+#define EF_MIPS_PIC	    2		/* Contains PIC code */
+#define EF_MIPS_CPIC	    4		/* Uses PIC calling sequence */
+#define EF_MIPS_XGOT	    8
+#define EF_MIPS_64BIT_WHIRL 16
+#define EF_MIPS_ABI2	    32
+#define EF_MIPS_ABI_ON32    64
+#define EF_MIPS_ARCH	    0xf0000000	/* MIPS architecture level */
+
+/* Legal values for MIPS architecture level.  */
+
+#define EF_MIPS_ARCH_1	    0x00000000	/* -mips1 code.  */
+#define EF_MIPS_ARCH_2	    0x10000000	/* -mips2 code.  */
+#define EF_MIPS_ARCH_3	    0x20000000	/* -mips3 code.  */
+#define EF_MIPS_ARCH_4	    0x30000000	/* -mips4 code.  */
+#define EF_MIPS_ARCH_5	    0x40000000	/* -mips5 code.  */
+#define EF_MIPS_ARCH_32	    0x60000000	/* MIPS32 code.  */
+#define EF_MIPS_ARCH_64	    0x70000000	/* MIPS64 code.  */
+
+/* The following are non-official names and should not be used.  */
+
+#define E_MIPS_ARCH_1	  0x00000000	/* -mips1 code.  */
+#define E_MIPS_ARCH_2	  0x10000000	/* -mips2 code.  */
+#define E_MIPS_ARCH_3	  0x20000000	/* -mips3 code.  */
+#define E_MIPS_ARCH_4	  0x30000000	/* -mips4 code.  */
+#define E_MIPS_ARCH_5	  0x40000000	/* -mips5 code.  */
+#define E_MIPS_ARCH_32	  0x60000000	/* MIPS32 code.  */
+#define E_MIPS_ARCH_64	  0x70000000	/* MIPS64 code.  */
+
+/* Special section indices.  */
+
+#define SHN_MIPS_ACOMMON    0xff00	/* Allocated common symbols */
+#define SHN_MIPS_TEXT	    0xff01	/* Allocated test symbols.  */
+#define SHN_MIPS_DATA	    0xff02	/* Allocated data symbols.  */
+#define SHN_MIPS_SCOMMON    0xff03	/* Small common symbols */
+#define SHN_MIPS_SUNDEFINED 0xff04	/* Small undefined symbols */
+
+/* Legal values for sh_type field of Elf32_Shdr.  */
+
+#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */
+#define SHT_MIPS_MSYM	       0x70000001
+#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */
+#define SHT_MIPS_GPTAB	       0x70000003 /* Global data area sizes */
+#define SHT_MIPS_UCODE	       0x70000004 /* Reserved for SGI/MIPS compilers */
+#define SHT_MIPS_DEBUG	       0x70000005 /* MIPS ECOFF debugging information*/
+#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */
+#define SHT_MIPS_PACKAGE       0x70000007
+#define SHT_MIPS_PACKSYM       0x70000008
+#define SHT_MIPS_RELD	       0x70000009
+#define SHT_MIPS_IFACE         0x7000000b
+#define SHT_MIPS_CONTENT       0x7000000c
+#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */
+#define SHT_MIPS_SHDR	       0x70000010
+#define SHT_MIPS_FDESC	       0x70000011
+#define SHT_MIPS_EXTSYM	       0x70000012
+#define SHT_MIPS_DENSE	       0x70000013
+#define SHT_MIPS_PDESC	       0x70000014
+#define SHT_MIPS_LOCSYM	       0x70000015
+#define SHT_MIPS_AUXSYM	       0x70000016
+#define SHT_MIPS_OPTSYM	       0x70000017
+#define SHT_MIPS_LOCSTR	       0x70000018
+#define SHT_MIPS_LINE	       0x70000019
+#define SHT_MIPS_RFDESC	       0x7000001a
+#define SHT_MIPS_DELTASYM      0x7000001b
+#define SHT_MIPS_DELTAINST     0x7000001c
+#define SHT_MIPS_DELTACLASS    0x7000001d
+#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */
+#define SHT_MIPS_DELTADECL     0x7000001f
+#define SHT_MIPS_SYMBOL_LIB    0x70000020
+#define SHT_MIPS_EVENTS	       0x70000021 /* Event section.  */
+#define SHT_MIPS_TRANSLATE     0x70000022
+#define SHT_MIPS_PIXIE	       0x70000023
+#define SHT_MIPS_XLATE	       0x70000024
+#define SHT_MIPS_XLATE_DEBUG   0x70000025
+#define SHT_MIPS_WHIRL	       0x70000026
+#define SHT_MIPS_EH_REGION     0x70000027
+#define SHT_MIPS_XLATE_OLD     0x70000028
+#define SHT_MIPS_PDR_EXCEPTION 0x70000029
+
+/* Legal values for sh_flags field of Elf32_Shdr.  */
+
+#define SHF_MIPS_GPREL	 0x10000000	/* Must be part of global data area */
+#define SHF_MIPS_MERGE	 0x20000000
+#define SHF_MIPS_ADDR	 0x40000000
+#define SHF_MIPS_STRINGS 0x80000000
+#define SHF_MIPS_NOSTRIP 0x08000000
+#define SHF_MIPS_LOCAL	 0x04000000
+#define SHF_MIPS_NAMES	 0x02000000
+#define SHF_MIPS_NODUPE	 0x01000000
+
+
+/* Symbol tables.  */
+
+/* MIPS specific values for `st_other'.  */
+#define STO_MIPS_DEFAULT		0x0
+#define STO_MIPS_INTERNAL		0x1
+#define STO_MIPS_HIDDEN			0x2
+#define STO_MIPS_PROTECTED		0x3
+#define STO_MIPS_SC_ALIGN_UNUSED	0xff
+
+/* MIPS specific values for `st_info'.  */
+#define STB_MIPS_SPLIT_COMMON		13
+
+/* Entries found in sections of type SHT_MIPS_GPTAB.  */
+
+typedef union
+{
+  struct
+    {
+      Elf32_Word gt_current_g_value;	/* -G value used for compilation */
+      Elf32_Word gt_unused;		/* Not used */
+    } gt_header;			/* First entry in section */
+  struct
+    {
+      Elf32_Word gt_g_value;		/* If this value were used for -G */
+      Elf32_Word gt_bytes;		/* This many bytes would be used */
+    } gt_entry;				/* Subsequent entries in section */
+} Elf32_gptab;
+
+/* Entry found in sections of type SHT_MIPS_REGINFO.  */
+
+typedef struct
+{
+  Elf32_Word	ri_gprmask;		/* General registers used */
+  Elf32_Word	ri_cprmask[4];		/* Coprocessor registers used */
+  Elf32_Sword	ri_gp_value;		/* $gp register value */
+} Elf32_RegInfo;
+
+/* Entries found in sections of type SHT_MIPS_OPTIONS.  */
+
+typedef struct
+{
+  unsigned char kind;		/* Determines interpretation of the
+				   variable part of descriptor.  */
+  unsigned char size;		/* Size of descriptor, including header.  */
+  Elf32_Section section;	/* Section header index of section affected,
+				   0 for global options.  */
+  Elf32_Word info;		/* Kind-specific information.  */
+} Elf_Options;
+
+/* Values for `kind' field in Elf_Options.  */
+
+#define ODK_NULL	0	/* Undefined.  */
+#define ODK_REGINFO	1	/* Register usage information.  */
+#define ODK_EXCEPTIONS	2	/* Exception processing options.  */
+#define ODK_PAD		3	/* Section padding options.  */
+#define ODK_HWPATCH	4	/* Hardware workarounds performed */
+#define ODK_FILL	5	/* record the fill value used by the linker. */
+#define ODK_TAGS	6	/* reserve space for desktop tools to write. */
+#define ODK_HWAND	7	/* HW workarounds.  'AND' bits when merging. */
+#define ODK_HWOR	8	/* HW workarounds.  'OR' bits when merging.  */
+
+/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */
+
+#define OEX_FPU_MIN	0x1f	/* FPE's which MUST be enabled.  */
+#define OEX_FPU_MAX	0x1f00	/* FPE's which MAY be enabled.  */
+#define OEX_PAGE0	0x10000	/* page zero must be mapped.  */
+#define OEX_SMM		0x20000	/* Force sequential memory mode?  */
+#define OEX_FPDBUG	0x40000	/* Force floating point debug mode?  */
+#define OEX_PRECISEFP	OEX_FPDBUG
+#define OEX_DISMISS	0x80000	/* Dismiss invalid address faults?  */
+
+#define OEX_FPU_INVAL	0x10
+#define OEX_FPU_DIV0	0x08
+#define OEX_FPU_OFLO	0x04
+#define OEX_FPU_UFLO	0x02
+#define OEX_FPU_INEX	0x01
+
+/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */
+
+#define OHW_R4KEOP	0x1	/* R4000 end-of-page patch.  */
+#define OHW_R8KPFETCH	0x2	/* may need R8000 prefetch patch.  */
+#define OHW_R5KEOP	0x4	/* R5000 end-of-page patch.  */
+#define OHW_R5KCVTL	0x8	/* R5000 cvt.[ds].l bug.  clean=1.  */
+
+#define OPAD_PREFIX	0x1
+#define OPAD_POSTFIX	0x2
+#define OPAD_SYMBOL	0x4
+
+/* Entry found in `.options' section.  */
+
+typedef struct
+{
+  Elf32_Word hwp_flags1;	/* Extra flags.  */
+  Elf32_Word hwp_flags2;	/* Extra flags.  */
+} Elf_Options_Hw;
+
+/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */
+
+#define OHWA0_R4KEOP_CHECKED	0x00000001
+#define OHWA1_R4KEOP_CLEAN	0x00000002
+
+/* MIPS relocs.  */
+
+#define R_MIPS_NONE		0	/* No reloc */
+#define R_MIPS_16		1	/* Direct 16 bit */
+#define R_MIPS_32		2	/* Direct 32 bit */
+#define R_MIPS_REL32		3	/* PC relative 32 bit */
+#define R_MIPS_26		4	/* Direct 26 bit shifted */
+#define R_MIPS_HI16		5	/* High 16 bit */
+#define R_MIPS_LO16		6	/* Low 16 bit */
+#define R_MIPS_GPREL16		7	/* GP relative 16 bit */
+#define R_MIPS_LITERAL		8	/* 16 bit literal entry */
+#define R_MIPS_GOT16		9	/* 16 bit GOT entry */
+#define R_MIPS_PC16		10	/* PC relative 16 bit */
+#define R_MIPS_CALL16		11	/* 16 bit GOT entry for function */
+#define R_MIPS_GPREL32		12	/* GP relative 32 bit */
+
+#define R_MIPS_SHIFT5		16
+#define R_MIPS_SHIFT6		17
+#define R_MIPS_64		18
+#define R_MIPS_GOT_DISP		19
+#define R_MIPS_GOT_PAGE		20
+#define R_MIPS_GOT_OFST		21
+#define R_MIPS_GOT_HI16		22
+#define R_MIPS_GOT_LO16		23
+#define R_MIPS_SUB		24
+#define R_MIPS_INSERT_A		25
+#define R_MIPS_INSERT_B		26
+#define R_MIPS_DELETE		27
+#define R_MIPS_HIGHER		28
+#define R_MIPS_HIGHEST		29
+#define R_MIPS_CALL_HI16	30
+#define R_MIPS_CALL_LO16	31
+#define R_MIPS_SCN_DISP		32
+#define R_MIPS_REL16		33
+#define R_MIPS_ADD_IMMEDIATE	34
+#define R_MIPS_PJUMP		35
+#define R_MIPS_RELGOT		36
+#define R_MIPS_JALR		37
+/* Keep this the last entry.  */
+#define R_MIPS_NUM		38
+
+/* Legal values for p_type field of Elf32_Phdr.  */
+
+#define PT_MIPS_REGINFO	0x70000000	/* Register usage information */
+#define PT_MIPS_RTPROC  0x70000001	/* Runtime procedure table. */
+#define PT_MIPS_OPTIONS 0x70000002
+
+/* Special program header types.  */
+
+#define PF_MIPS_LOCAL	0x10000000
+
+/* Legal values for d_tag field of Elf32_Dyn.  */
+
+#define DT_MIPS_RLD_VERSION  0x70000001	/* Runtime linker interface version */
+#define DT_MIPS_TIME_STAMP   0x70000002	/* Timestamp */
+#define DT_MIPS_ICHECKSUM    0x70000003	/* Checksum */
+#define DT_MIPS_IVERSION     0x70000004	/* Version string (string tbl index) */
+#define DT_MIPS_FLAGS	     0x70000005	/* Flags */
+#define DT_MIPS_BASE_ADDRESS 0x70000006	/* Base address */
+#define DT_MIPS_MSYM	     0x70000007
+#define DT_MIPS_CONFLICT     0x70000008	/* Address of CONFLICT section */
+#define DT_MIPS_LIBLIST	     0x70000009	/* Address of LIBLIST section */
+#define DT_MIPS_LOCAL_GOTNO  0x7000000a	/* Number of local GOT entries */
+#define DT_MIPS_CONFLICTNO   0x7000000b	/* Number of CONFLICT entries */
+#define DT_MIPS_LIBLISTNO    0x70000010	/* Number of LIBLIST entries */
+#define DT_MIPS_SYMTABNO     0x70000011	/* Number of DYNSYM entries */
+#define DT_MIPS_UNREFEXTNO   0x70000012	/* First external DYNSYM */
+#define DT_MIPS_GOTSYM	     0x70000013	/* First GOT entry in DYNSYM */
+#define DT_MIPS_HIPAGENO     0x70000014	/* Number of GOT page table entries */
+#define DT_MIPS_RLD_MAP	     0x70000016	/* Address of run time loader map.  */
+#define DT_MIPS_DELTA_CLASS  0x70000017	/* Delta C++ class definition.  */
+#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in
+						DT_MIPS_DELTA_CLASS.  */
+#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */
+#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in
+						DT_MIPS_DELTA_INSTANCE.  */
+#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */
+#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in
+					     DT_MIPS_DELTA_RELOC.  */
+#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta
+					   relocations refer to.  */
+#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in
+					   DT_MIPS_DELTA_SYM.  */
+#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the
+					     class declaration.  */
+#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in
+						DT_MIPS_DELTA_CLASSSYM.  */
+#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */
+#define DT_MIPS_PIXIE_INIT   0x70000023
+#define DT_MIPS_SYMBOL_LIB   0x70000024
+#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025
+#define DT_MIPS_LOCAL_GOTIDX 0x70000026
+#define DT_MIPS_HIDDEN_GOTIDX 0x70000027
+#define DT_MIPS_PROTECTED_GOTIDX 0x70000028
+#define DT_MIPS_OPTIONS	     0x70000029 /* Address of .options.  */
+#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */
+#define DT_MIPS_DYNSTR_ALIGN 0x7000002b
+#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */
+#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve
+						    function stored in GOT.  */
+#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added
+					   by rld on dlopen() calls.  */
+#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */
+#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */
+#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */
+#define DT_MIPS_NUM	     0x32
+
+/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */
+
+#define RHF_NONE		   0		/* No flags */
+#define RHF_QUICKSTART		   (1 << 0)	/* Use quickstart */
+#define RHF_NOTPOT		   (1 << 1)	/* Hash size not power of 2 */
+#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)	/* Ignore LD_LIBRARY_PATH */
+#define RHF_NO_MOVE		   (1 << 3)
+#define RHF_SGI_ONLY		   (1 << 4)
+#define RHF_GUARANTEE_INIT	   (1 << 5)
+#define RHF_DELTA_C_PLUS_PLUS	   (1 << 6)
+#define RHF_GUARANTEE_START_INIT   (1 << 7)
+#define RHF_PIXIE		   (1 << 8)
+#define RHF_DEFAULT_DELAY_LOAD	   (1 << 9)
+#define RHF_REQUICKSTART	   (1 << 10)
+#define RHF_REQUICKSTARTED	   (1 << 11)
+#define RHF_CORD		   (1 << 12)
+#define RHF_NO_UNRES_UNDEF	   (1 << 13)
+#define RHF_RLD_ORDER_SAFE	   (1 << 14)
+
+/* Entries found in sections of type SHT_MIPS_LIBLIST.  */
+
+typedef struct
+{
+  Elf32_Word l_name;		/* Name (string table index) */
+  Elf32_Word l_time_stamp;	/* Timestamp */
+  Elf32_Word l_checksum;	/* Checksum */
+  Elf32_Word l_version;		/* Interface version */
+  Elf32_Word l_flags;		/* Flags */
+} Elf32_Lib;
+
+typedef struct
+{
+  Elf64_Word l_name;		/* Name (string table index) */
+  Elf64_Word l_time_stamp;	/* Timestamp */
+  Elf64_Word l_checksum;	/* Checksum */
+  Elf64_Word l_version;		/* Interface version */
+  Elf64_Word l_flags;		/* Flags */
+} Elf64_Lib;
+
+
+/* Legal values for l_flags.  */
+
+#define LL_NONE		  0
+#define LL_EXACT_MATCH	  (1 << 0)	/* Require exact match */
+#define LL_IGNORE_INT_VER (1 << 1)	/* Ignore interface version */
+#define LL_REQUIRE_MINOR  (1 << 2)
+#define LL_EXPORTS	  (1 << 3)
+#define LL_DELAY_LOAD	  (1 << 4)
+#define LL_DELTA	  (1 << 5)
+
+/* Entries found in sections of type SHT_MIPS_CONFLICT.  */
+
+typedef Elf32_Addr Elf32_Conflict;
+
+
+/* HPPA specific definitions.  */
+
+/* Legal values for e_flags field of Elf32_Ehdr.  */
+
+#define EF_PARISC_TRAPNIL	0x00010000 /* Trap nil pointer dereference.  */
+#define EF_PARISC_EXT		0x00020000 /* Program uses arch. extensions. */
+#define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
+#define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
+#define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
+					      prediction.  */
+#define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
+#define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */
+
+/* Defined values for `e_flags & EF_PARISC_ARCH' are:  */
+
+#define EFA_PARISC_1_0		    0x020b /* PA-RISC 1.0 big-endian.  */
+#define EFA_PARISC_1_1		    0x0210 /* PA-RISC 1.1 big-endian.  */
+#define EFA_PARISC_2_0		    0x0214 /* PA-RISC 2.0 big-endian.  */
+
+/* Additional section indeces.  */
+
+#define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tenatively declared
+					      symbols in ANSI C.  */
+#define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.  */
+
+/* Legal values for sh_type field of Elf32_Shdr.  */
+
+#define SHT_PARISC_EXT		0x70000000 /* Contains product specific ext. */
+#define SHT_PARISC_UNWIND	0x70000001 /* Unwind information.  */
+#define SHT_PARISC_DOC		0x70000002 /* Debug info for optimized code. */
+
+/* Legal values for sh_flags field of Elf32_Shdr.  */
+
+#define SHF_PARISC_SHORT	0x20000000 /* Section with short addressing. */
+#define SHF_PARISC_HUGE		0x40000000 /* Section far from gp.  */
+#define SHF_PARISC_SBP		0x80000000 /* Static branch prediction code. */
+
+/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
+
+#define STT_PARISC_MILLICODE	13	/* Millicode function entry point.  */
+
+#define STT_HP_OPAQUE		(STT_LOOS + 0x1)
+#define STT_HP_STUB		(STT_LOOS + 0x2)
+
+/* HPPA relocs.  */
+
+#define R_PARISC_NONE		0	/* No reloc.  */
+#define R_PARISC_DIR32		1	/* Direct 32-bit reference.  */
+#define R_PARISC_DIR21L		2	/* Left 21 bits of eff. address.  */
+#define R_PARISC_DIR17R		3	/* Right 17 bits of eff. address.  */
+#define R_PARISC_DIR17F		4	/* 17 bits of eff. address.  */
+#define R_PARISC_DIR14R		6	/* Right 14 bits of eff. address.  */
+#define R_PARISC_PCREL32	9	/* 32-bit rel. address.  */
+#define R_PARISC_PCREL21L	10	/* Left 21 bits of rel. address.  */
+#define R_PARISC_PCREL17R	11	/* Right 17 bits of rel. address.  */
+#define R_PARISC_PCREL17F	12	/* 17 bits of rel. address.  */
+#define R_PARISC_PCREL14R	14	/* Right 14 bits of rel. address.  */
+#define R_PARISC_DPREL21L	18	/* Left 21 bits of rel. address.  */
+#define R_PARISC_DPREL14R	22	/* Right 14 bits of rel. address.  */
+#define R_PARISC_GPREL21L	26	/* GP-relative, left 21 bits.  */
+#define R_PARISC_GPREL14R	30	/* GP-relative, right 14 bits.  */
+#define R_PARISC_LTOFF21L	34	/* LT-relative, left 21 bits.  */
+#define R_PARISC_LTOFF14R	38	/* LT-relative, right 14 bits.  */
+#define R_PARISC_SECREL32	41	/* 32 bits section rel. address.  */
+#define R_PARISC_SEGBASE	48	/* No relocation, set segment base.  */
+#define R_PARISC_SEGREL32	49	/* 32 bits segment rel. address.  */
+#define R_PARISC_PLTOFF21L	50	/* PLT rel. address, left 21 bits.  */
+#define R_PARISC_PLTOFF14R	54	/* PLT rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF_FPTR32	57	/* 32 bits LT-rel. function pointer. */
+#define R_PARISC_LTOFF_FPTR21L	58	/* LT-rel. fct ptr, left 21 bits. */
+#define R_PARISC_LTOFF_FPTR14R	62	/* LT-rel. fct ptr, right 14 bits. */
+#define R_PARISC_FPTR64		64	/* 64 bits function address.  */
+#define R_PARISC_PLABEL32	65	/* 32 bits function address.  */
+#define R_PARISC_PLABEL21L	66	/* Left 21 bits of fct ptr.  */
+#define R_PARISC_PLABEL14R	70	/* Left 21 bits of fct ptr.  */
+#define R_PARISC_PCREL64	72	/* 64 bits PC-rel. address.  */
+#define R_PARISC_PCREL22F	74	/* 22 bits PC-rel. address.  */
+#define R_PARISC_PCREL14WR	75	/* PC-rel. address, right 14 bits.  */
+#define R_PARISC_PCREL14DR	76	/* PC rel. address, right 14 bits.  */
+#define R_PARISC_PCREL16F	77	/* 16 bits PC-rel. address.  */
+#define R_PARISC_PCREL16WF	78	/* 16 bits PC-rel. address.  */
+#define R_PARISC_PCREL16DF	79	/* 16 bits PC-rel. address.  */
+#define R_PARISC_DIR64		80	/* 64 bits of eff. address.  */
+#define R_PARISC_DIR14WR	83	/* 14 bits of eff. address.  */
+#define R_PARISC_DIR14DR	84	/* 14 bits of eff. address.  */
+#define R_PARISC_DIR16F		85	/* 16 bits of eff. address.  */
+#define R_PARISC_DIR16WF	86	/* 16 bits of eff. address.  */
+#define R_PARISC_DIR16DF	87	/* 16 bits of eff. address.  */
+#define R_PARISC_GPREL64	88	/* 64 bits of GP-rel. address.  */
+#define R_PARISC_GPREL14WR	91	/* GP-rel. address, right 14 bits.  */
+#define R_PARISC_GPREL14DR	92	/* GP-rel. address, right 14 bits.  */
+#define R_PARISC_GPREL16F	93	/* 16 bits GP-rel. address.  */
+#define R_PARISC_GPREL16WF	94	/* 16 bits GP-rel. address.  */
+#define R_PARISC_GPREL16DF	95	/* 16 bits GP-rel. address.  */
+#define R_PARISC_LTOFF64	96	/* 64 bits LT-rel. address.  */
+#define R_PARISC_LTOFF14WR	99	/* LT-rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF14DR	100	/* LT-rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF16F	101	/* 16 bits LT-rel. address.  */
+#define R_PARISC_LTOFF16WF	102	/* 16 bits LT-rel. address.  */
+#define R_PARISC_LTOFF16DF	103	/* 16 bits LT-rel. address.  */
+#define R_PARISC_SECREL64	104	/* 64 bits section rel. address.  */
+#define R_PARISC_SEGREL64	112	/* 64 bits segment rel. address.  */
+#define R_PARISC_PLTOFF14WR	115	/* PLT-rel. address, right 14 bits.  */
+#define R_PARISC_PLTOFF14DR	116	/* PLT-rel. address, right 14 bits.  */
+#define R_PARISC_PLTOFF16F	117	/* 16 bits LT-rel. address.  */
+#define R_PARISC_PLTOFF16WF	118	/* 16 bits PLT-rel. address.  */
+#define R_PARISC_PLTOFF16DF	119	/* 16 bits PLT-rel. address.  */
+#define R_PARISC_LTOFF_FPTR64	120	/* 64 bits LT-rel. function ptr.  */
+#define R_PARISC_LTOFF_FPTR14WR	123	/* LT-rel. fct. ptr., right 14 bits. */
+#define R_PARISC_LTOFF_FPTR14DR	124	/* LT-rel. fct. ptr., right 14 bits. */
+#define R_PARISC_LTOFF_FPTR16F	125	/* 16 bits LT-rel. function ptr.  */
+#define R_PARISC_LTOFF_FPTR16WF	126	/* 16 bits LT-rel. function ptr.  */
+#define R_PARISC_LTOFF_FPTR16DF	127	/* 16 bits LT-rel. function ptr.  */
+#define R_PARISC_LORESERVE	128
+#define R_PARISC_COPY		128	/* Copy relocation.  */
+#define R_PARISC_IPLT		129	/* Dynamic reloc, imported PLT */
+#define R_PARISC_EPLT		130	/* Dynamic reloc, exported PLT */
+#define R_PARISC_TPREL32	153	/* 32 bits TP-rel. address.  */
+#define R_PARISC_TPREL21L	154	/* TP-rel. address, left 21 bits.  */
+#define R_PARISC_TPREL14R	158	/* TP-rel. address, right 14 bits.  */
+#define R_PARISC_LTOFF_TP21L	162	/* LT-TP-rel. address, left 21 bits. */
+#define R_PARISC_LTOFF_TP14R	166	/* LT-TP-rel. address, right 14 bits.*/
+#define R_PARISC_LTOFF_TP14F	167	/* 14 bits LT-TP-rel. address.  */
+#define R_PARISC_TPREL64	216	/* 64 bits TP-rel. address.  */
+#define R_PARISC_TPREL14WR	219	/* TP-rel. address, right 14 bits.  */
+#define R_PARISC_TPREL14DR	220	/* TP-rel. address, right 14 bits.  */
+#define R_PARISC_TPREL16F	221	/* 16 bits TP-rel. address.  */
+#define R_PARISC_TPREL16WF	222	/* 16 bits TP-rel. address.  */
+#define R_PARISC_TPREL16DF	223	/* 16 bits TP-rel. address.  */
+#define R_PARISC_LTOFF_TP64	224	/* 64 bits LT-TP-rel. address.  */
+#define R_PARISC_LTOFF_TP14WR	227	/* LT-TP-rel. address, right 14 bits.*/
+#define R_PARISC_LTOFF_TP14DR	228	/* LT-TP-rel. address, right 14 bits.*/
+#define R_PARISC_LTOFF_TP16F	229	/* 16 bits LT-TP-rel. address.  */
+#define R_PARISC_LTOFF_TP16WF	230	/* 16 bits LT-TP-rel. address.  */
+#define R_PARISC_LTOFF_TP16DF	231	/* 16 bits LT-TP-rel. address.  */
+#define R_PARISC_HIRESERVE	255
+
+/* Legal values for p_type field of Elf32_Phdr/Elf64_Phdr.  */
+
+#define PT_HP_TLS		(PT_LOOS + 0x0)
+#define PT_HP_CORE_NONE		(PT_LOOS + 0x1)
+#define PT_HP_CORE_VERSION	(PT_LOOS + 0x2)
+#define PT_HP_CORE_KERNEL	(PT_LOOS + 0x3)
+#define PT_HP_CORE_COMM		(PT_LOOS + 0x4)
+#define PT_HP_CORE_PROC		(PT_LOOS + 0x5)
+#define PT_HP_CORE_LOADABLE	(PT_LOOS + 0x6)
+#define PT_HP_CORE_STACK	(PT_LOOS + 0x7)
+#define PT_HP_CORE_SHM		(PT_LOOS + 0x8)
+#define PT_HP_CORE_MMF		(PT_LOOS + 0x9)
+#define PT_HP_PARALLEL		(PT_LOOS + 0x10)
+#define PT_HP_FASTBIND		(PT_LOOS + 0x11)
+#define PT_HP_OPT_ANNOT		(PT_LOOS + 0x12)
+#define PT_HP_HSL_ANNOT		(PT_LOOS + 0x13)
+#define PT_HP_STACK		(PT_LOOS + 0x14)
+
+#define PT_PARISC_ARCHEXT	0x70000000
+#define PT_PARISC_UNWIND	0x70000001
+
+/* Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr.  */
+
+#define PF_PARISC_SBP		0x08000000
+
+#define PF_HP_PAGE_SIZE		0x00100000
+#define PF_HP_FAR_SHARED	0x00200000
+#define PF_HP_NEAR_SHARED	0x00400000
+#define PF_HP_CODE		0x01000000
+#define PF_HP_MODIFY		0x02000000
+#define PF_HP_LAZYSWAP		0x04000000
+#define PF_HP_SBP		0x08000000
+
+
+/* Alpha specific definitions.  */
+
+/* Legal values for e_flags field of Elf64_Ehdr.  */
+
+#define EF_ALPHA_32BIT		1	/* All addresses must be < 2GB.  */
+#define EF_ALPHA_CANRELAX	2	/* Relocations for relaxing exist.  */
+
+/* Legal values for sh_type field of Elf64_Shdr.  */
+
+/* These two are primerily concerned with ECOFF debugging info.  */
+#define SHT_ALPHA_DEBUG		0x70000001
+#define SHT_ALPHA_REGINFO	0x70000002
+
+/* Legal values for sh_flags field of Elf64_Shdr.  */
+
+#define SHF_ALPHA_GPREL		0x10000000
+
+/* Legal values for st_other field of Elf64_Sym.  */
+#define STO_ALPHA_NOPV		0x80	/* No PV required.  */
+#define STO_ALPHA_STD_GPLOAD	0x88	/* PV only used for initial ldgp.  */
+
+/* Alpha relocs.  */
+
+#define R_ALPHA_NONE		0	/* No reloc */
+#define R_ALPHA_REFLONG		1	/* Direct 32 bit */
+#define R_ALPHA_REFQUAD		2	/* Direct 64 bit */
+#define R_ALPHA_GPREL32		3	/* GP relative 32 bit */
+#define R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
+#define R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
+#define R_ALPHA_GPDISP		6	/* Add displacement to GP */
+#define R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
+#define R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
+#define R_ALPHA_SREL16		9	/* PC relative 16 bit */
+#define R_ALPHA_SREL32		10	/* PC relative 32 bit */
+#define R_ALPHA_SREL64		11	/* PC relative 64 bit */
+#define R_ALPHA_GPRELHIGH	17	/* GP relative 32 bit, high 16 bits */
+#define R_ALPHA_GPRELLOW	18	/* GP relative 32 bit, low 16 bits */
+#define R_ALPHA_GPREL16		19	/* GP relative 16 bit */
+#define R_ALPHA_COPY		24	/* Copy symbol at runtime */
+#define R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
+#define R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
+#define R_ALPHA_RELATIVE	27	/* Adjust by program base */
+#define R_ALPHA_TLS_GD_HI	28
+#define R_ALPHA_TLSGD		29
+#define R_ALPHA_TLS_LDM		30
+#define R_ALPHA_DTPMOD64	31
+#define R_ALPHA_GOTDTPREL	32
+#define R_ALPHA_DTPREL64	33
+#define R_ALPHA_DTPRELHI	34
+#define R_ALPHA_DTPRELLO	35
+#define R_ALPHA_DTPREL16	36
+#define R_ALPHA_GOTTPREL	37
+#define R_ALPHA_TPREL64		38
+#define R_ALPHA_TPRELHI		39
+#define R_ALPHA_TPRELLO		40
+#define R_ALPHA_TPREL16		41
+/* Keep this the last entry.  */
+#define R_ALPHA_NUM		46
+
+/* Magic values of the LITUSE relocation addend.  */
+#define LITUSE_ALPHA_ADDR	0
+#define LITUSE_ALPHA_BASE	1
+#define LITUSE_ALPHA_BYTOFF	2
+#define LITUSE_ALPHA_JSR	3
+#define LITUSE_ALPHA_TLS_GD	4
+#define LITUSE_ALPHA_TLS_LDM	5
+
+
+/* PowerPC specific declarations */
+
+/* Values for Elf32/64_Ehdr.e_flags.  */
+#define EF_PPC_EMB		0x80000000	/* PowerPC embedded flag */
+
+/* Cygnus local bits below */
+#define EF_PPC_RELOCATABLE	0x00010000	/* PowerPC -mrelocatable flag*/
+#define EF_PPC_RELOCATABLE_LIB	0x00008000	/* PowerPC -mrelocatable-lib
+						   flag */
+
+/* PowerPC relocations defined by the ABIs */
+#define R_PPC_NONE		0
+#define R_PPC_ADDR32		1	/* 32bit absolute address */
+#define R_PPC_ADDR24		2	/* 26bit address, 2 bits ignored.  */
+#define R_PPC_ADDR16		3	/* 16bit absolute address */
+#define R_PPC_ADDR16_LO		4	/* lower 16bit of absolute address */
+#define R_PPC_ADDR16_HI		5	/* high 16bit of absolute address */
+#define R_PPC_ADDR16_HA		6	/* adjusted high 16bit */
+#define R_PPC_ADDR14		7	/* 16bit address, 2 bits ignored */
+#define R_PPC_ADDR14_BRTAKEN	8
+#define R_PPC_ADDR14_BRNTAKEN	9
+#define R_PPC_REL24		10	/* PC relative 26 bit */
+#define R_PPC_REL14		11	/* PC relative 16 bit */
+#define R_PPC_REL14_BRTAKEN	12
+#define R_PPC_REL14_BRNTAKEN	13
+#define R_PPC_GOT16		14
+#define R_PPC_GOT16_LO		15
+#define R_PPC_GOT16_HI		16
+#define R_PPC_GOT16_HA		17
+#define R_PPC_PLTREL24		18
+#define R_PPC_COPY		19
+#define R_PPC_GLOB_DAT		20
+#define R_PPC_JMP_SLOT		21
+#define R_PPC_RELATIVE		22
+#define R_PPC_LOCAL24PC		23
+#define R_PPC_UADDR32		24
+#define R_PPC_UADDR16		25
+#define R_PPC_REL32		26
+#define R_PPC_PLT32		27
+#define R_PPC_PLTREL32		28
+#define R_PPC_PLT16_LO		29
+#define R_PPC_PLT16_HI		30
+#define R_PPC_PLT16_HA		31
+#define R_PPC_SDAREL16		32
+#define R_PPC_SECTOFF		33
+#define R_PPC_SECTOFF_LO	34
+#define R_PPC_SECTOFF_HI	35
+#define R_PPC_SECTOFF_HA	36
+
+/* PowerPC relocations defined for the TLS access ABI.  */
+#define R_PPC_TLS		67 /* none	(sym+add)@tls */
+#define R_PPC_DTPMOD32		68 /* word32	(sym+add)@dtpmod */
+#define R_PPC_TPREL16		69 /* half16*	(sym+add)@tprel */
+#define R_PPC_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
+#define R_PPC_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
+#define R_PPC_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
+#define R_PPC_TPREL32		73 /* word32	(sym+add)@tprel */
+#define R_PPC_DTPREL16		74 /* half16*	(sym+add)@dtprel */
+#define R_PPC_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
+#define R_PPC_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
+#define R_PPC_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
+#define R_PPC_DTPREL32		78 /* word32	(sym+add)@dtprel */
+#define R_PPC_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
+#define R_PPC_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
+#define R_PPC_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
+#define R_PPC_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
+#define R_PPC_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
+#define R_PPC_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
+#define R_PPC_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
+#define R_PPC_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
+#define R_PPC_GOT_TPREL16	87 /* half16*	(sym+add)@got@tprel */
+#define R_PPC_GOT_TPREL16_LO	88 /* half16	(sym+add)@got@tprel@l */
+#define R_PPC_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
+#define R_PPC_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
+#define R_PPC_GOT_DTPREL16	91 /* half16*	(sym+add)@got@dtprel */
+#define R_PPC_GOT_DTPREL16_LO	92 /* half16*	(sym+add)@got@dtprel@l */
+#define R_PPC_GOT_DTPREL16_HI	93 /* half16*	(sym+add)@got@dtprel@h */
+#define R_PPC_GOT_DTPREL16_HA	94 /* half16*	(sym+add)@got@dtprel@ha */
+
+/* Keep this the last entry.  */
+#define R_PPC_NUM		95
+
+/* The remaining relocs are from the Embedded ELF ABI, and are not
+   in the SVR4 ELF ABI.  */
+#define R_PPC_EMB_NADDR32	101
+#define R_PPC_EMB_NADDR16	102
+#define R_PPC_EMB_NADDR16_LO	103
+#define R_PPC_EMB_NADDR16_HI	104
+#define R_PPC_EMB_NADDR16_HA	105
+#define R_PPC_EMB_SDAI16	106
+#define R_PPC_EMB_SDA2I16	107
+#define R_PPC_EMB_SDA2REL	108
+#define R_PPC_EMB_SDA21		109	/* 16 bit offset in SDA */
+#define R_PPC_EMB_MRKREF	110
+#define R_PPC_EMB_RELSEC16	111
+#define R_PPC_EMB_RELST_LO	112
+#define R_PPC_EMB_RELST_HI	113
+#define R_PPC_EMB_RELST_HA	114
+#define R_PPC_EMB_BIT_FLD	115
+#define R_PPC_EMB_RELSDA	116	/* 16 bit relative offset in SDA */
+
+/* Diab tool relocations.  */
+#define R_PPC_DIAB_SDA21_LO	180	/* like EMB_SDA21, but lower 16 bit */
+#define R_PPC_DIAB_SDA21_HI	181	/* like EMB_SDA21, but high 16 bit */
+#define R_PPC_DIAB_SDA21_HA	182	/* like EMB_SDA21, adjusted high 16 */
+#define R_PPC_DIAB_RELSDA_LO	183	/* like EMB_RELSDA, but lower 16 bit */
+#define R_PPC_DIAB_RELSDA_HI	184	/* like EMB_RELSDA, but high 16 bit */
+#define R_PPC_DIAB_RELSDA_HA	185	/* like EMB_RELSDA, adjusted high 16 */
+
+/* This is a phony reloc to handle any old fashioned TOC16 references
+   that may still be in object files.  */
+#define R_PPC_TOC16		255
+
+
+/* PowerPC64 relocations defined by the ABIs */
+#define R_PPC64_NONE		R_PPC_NONE
+#define R_PPC64_ADDR32		R_PPC_ADDR32 /* 32bit absolute address */
+#define R_PPC64_ADDR24		R_PPC_ADDR24 /* 26bit address, word aligned */
+#define R_PPC64_ADDR16		R_PPC_ADDR16 /* 16bit absolute address */
+#define R_PPC64_ADDR16_LO	R_PPC_ADDR16_LO	/* lower 16bits of address */
+#define R_PPC64_ADDR16_HI	R_PPC_ADDR16_HI	/* high 16bits of address. */
+#define R_PPC64_ADDR16_HA	R_PPC_ADDR16_HA /* adjusted high 16bits.  */
+#define R_PPC64_ADDR14		R_PPC_ADDR14 /* 16bit address, word aligned */
+#define R_PPC64_ADDR14_BRTAKEN	R_PPC_ADDR14_BRTAKEN
+#define R_PPC64_ADDR14_BRNTAKEN	R_PPC_ADDR14_BRNTAKEN
+#define R_PPC64_REL24		R_PPC_REL24 /* PC-rel. 26 bit, word aligned */
+#define R_PPC64_REL14		R_PPC_REL14 /* PC relative 16 bit */
+#define R_PPC64_REL14_BRTAKEN	R_PPC_REL14_BRTAKEN
+#define R_PPC64_REL14_BRNTAKEN	R_PPC_REL14_BRNTAKEN
+#define R_PPC64_GOT16		R_PPC_GOT16
+#define R_PPC64_GOT16_LO	R_PPC_GOT16_LO
+#define R_PPC64_GOT16_HI	R_PPC_GOT16_HI
+#define R_PPC64_GOT16_HA	R_PPC_GOT16_HA
+
+#define R_PPC64_COPY		R_PPC_COPY
+#define R_PPC64_GLOB_DAT	R_PPC_GLOB_DAT
+#define R_PPC64_JMP_SLOT	R_PPC_JMP_SLOT
+#define R_PPC64_RELATIVE	R_PPC_RELATIVE
+
+#define R_PPC64_UADDR32		R_PPC_UADDR32
+#define R_PPC64_UADDR16		R_PPC_UADDR16
+#define R_PPC64_REL32		R_PPC_REL32
+#define R_PPC64_PLT32		R_PPC_PLT32
+#define R_PPC64_PLTREL32	R_PPC_PLTREL32
+#define R_PPC64_PLT16_LO	R_PPC_PLT16_LO
+#define R_PPC64_PLT16_HI	R_PPC_PLT16_HI
+#define R_PPC64_PLT16_HA	R_PPC_PLT16_HA
+
+#define R_PPC64_SECTOFF		R_PPC_SECTOFF
+#define R_PPC64_SECTOFF_LO	R_PPC_SECTOFF_LO
+#define R_PPC64_SECTOFF_HI	R_PPC_SECTOFF_HI
+#define R_PPC64_SECTOFF_HA	R_PPC_SECTOFF_HA
+#define R_PPC64_ADDR30		37 /* word30 (S + A - P) >> 2 */
+#define R_PPC64_ADDR64		38 /* doubleword64 S + A */
+#define R_PPC64_ADDR16_HIGHER	39 /* half16 #higher(S + A) */
+#define R_PPC64_ADDR16_HIGHERA	40 /* half16 #highera(S + A) */
+#define R_PPC64_ADDR16_HIGHEST	41 /* half16 #highest(S + A) */
+#define R_PPC64_ADDR16_HIGHESTA	42 /* half16 #highesta(S + A) */
+#define R_PPC64_UADDR64		43 /* doubleword64 S + A */
+#define R_PPC64_REL64		44 /* doubleword64 S + A - P */
+#define R_PPC64_PLT64		45 /* doubleword64 L + A */
+#define R_PPC64_PLTREL64	46 /* doubleword64 L + A - P */
+#define R_PPC64_TOC16		47 /* half16* S + A - .TOC */
+#define R_PPC64_TOC16_LO	48 /* half16 #lo(S + A - .TOC.) */
+#define R_PPC64_TOC16_HI	49 /* half16 #hi(S + A - .TOC.) */
+#define R_PPC64_TOC16_HA	50 /* half16 #ha(S + A - .TOC.) */
+#define R_PPC64_TOC		51 /* doubleword64 .TOC */
+#define R_PPC64_PLTGOT16	52 /* half16* M + A */
+#define R_PPC64_PLTGOT16_LO	53 /* half16 #lo(M + A) */
+#define R_PPC64_PLTGOT16_HI	54 /* half16 #hi(M + A) */
+#define R_PPC64_PLTGOT16_HA	55 /* half16 #ha(M + A) */
+
+#define R_PPC64_ADDR16_DS	56 /* half16ds* (S + A) >> 2 */
+#define R_PPC64_ADDR16_LO_DS	57 /* half16ds  #lo(S + A) >> 2 */
+#define R_PPC64_GOT16_DS	58 /* half16ds* (G + A) >> 2 */
+#define R_PPC64_GOT16_LO_DS	59 /* half16ds  #lo(G + A) >> 2 */
+#define R_PPC64_PLT16_LO_DS	60 /* half16ds  #lo(L + A) >> 2 */
+#define R_PPC64_SECTOFF_DS	61 /* half16ds* (R + A) >> 2 */
+#define R_PPC64_SECTOFF_LO_DS	62 /* half16ds  #lo(R + A) >> 2 */
+#define R_PPC64_TOC16_DS	63 /* half16ds* (S + A - .TOC.) >> 2 */
+#define R_PPC64_TOC16_LO_DS	64 /* half16ds  #lo(S + A - .TOC.) >> 2 */
+#define R_PPC64_PLTGOT16_DS	65 /* half16ds* (M + A) >> 2 */
+#define R_PPC64_PLTGOT16_LO_DS	66 /* half16ds  #lo(M + A) >> 2 */
+
+/* PowerPC64 relocations defined for the TLS access ABI.  */
+#define R_PPC64_TLS		67 /* none	(sym+add)@tls */
+#define R_PPC64_DTPMOD64	68 /* doubleword64 (sym+add)@dtpmod */
+#define R_PPC64_TPREL16		69 /* half16*	(sym+add)@tprel */
+#define R_PPC64_TPREL16_LO	70 /* half16	(sym+add)@tprel@l */
+#define R_PPC64_TPREL16_HI	71 /* half16	(sym+add)@tprel@h */
+#define R_PPC64_TPREL16_HA	72 /* half16	(sym+add)@tprel@ha */
+#define R_PPC64_TPREL64		73 /* doubleword64 (sym+add)@tprel */
+#define R_PPC64_DTPREL16	74 /* half16*	(sym+add)@dtprel */
+#define R_PPC64_DTPREL16_LO	75 /* half16	(sym+add)@dtprel@l */
+#define R_PPC64_DTPREL16_HI	76 /* half16	(sym+add)@dtprel@h */
+#define R_PPC64_DTPREL16_HA	77 /* half16	(sym+add)@dtprel@ha */
+#define R_PPC64_DTPREL64	78 /* doubleword64 (sym+add)@dtprel */
+#define R_PPC64_GOT_TLSGD16	79 /* half16*	(sym+add)@got@tlsgd */
+#define R_PPC64_GOT_TLSGD16_LO	80 /* half16	(sym+add)@got@tlsgd@l */
+#define R_PPC64_GOT_TLSGD16_HI	81 /* half16	(sym+add)@got@tlsgd@h */
+#define R_PPC64_GOT_TLSGD16_HA	82 /* half16	(sym+add)@got@tlsgd@ha */
+#define R_PPC64_GOT_TLSLD16	83 /* half16*	(sym+add)@got@tlsld */
+#define R_PPC64_GOT_TLSLD16_LO	84 /* half16	(sym+add)@got@tlsld@l */
+#define R_PPC64_GOT_TLSLD16_HI	85 /* half16	(sym+add)@got@tlsld@h */
+#define R_PPC64_GOT_TLSLD16_HA	86 /* half16	(sym+add)@got@tlsld@ha */
+#define R_PPC64_GOT_TPREL16_DS	87 /* half16ds*	(sym+add)@got@tprel */
+#define R_PPC64_GOT_TPREL16_LO_DS 88 /* half16ds (sym+add)@got@tprel@l */
+#define R_PPC64_GOT_TPREL16_HI	89 /* half16	(sym+add)@got@tprel@h */
+#define R_PPC64_GOT_TPREL16_HA	90 /* half16	(sym+add)@got@tprel@ha */
+#define R_PPC64_GOT_DTPREL16_DS	91 /* half16ds*	(sym+add)@got@dtprel */
+#define R_PPC64_GOT_DTPREL16_LO_DS 92 /* half16ds (sym+add)@got@dtprel@l */
+#define R_PPC64_GOT_DTPREL16_HI	93 /* half16	(sym+add)@got@dtprel@h */
+#define R_PPC64_GOT_DTPREL16_HA	94 /* half16	(sym+add)@got@dtprel@ha */
+#define R_PPC64_TPREL16_DS	95 /* half16ds*	(sym+add)@tprel */
+#define R_PPC64_TPREL16_LO_DS	96 /* half16ds	(sym+add)@tprel@l */
+#define R_PPC64_TPREL16_HIGHER	97 /* half16	(sym+add)@tprel@higher */
+#define R_PPC64_TPREL16_HIGHERA	98 /* half16	(sym+add)@tprel@highera */
+#define R_PPC64_TPREL16_HIGHEST	99 /* half16	(sym+add)@tprel@highest */
+#define R_PPC64_TPREL16_HIGHESTA 100 /* half16	(sym+add)@tprel@highesta */
+#define R_PPC64_DTPREL16_DS	101 /* half16ds* (sym+add)@dtprel */
+#define R_PPC64_DTPREL16_LO_DS	102 /* half16ds	(sym+add)@dtprel@l */
+#define R_PPC64_DTPREL16_HIGHER	103 /* half16	(sym+add)@dtprel@higher */
+#define R_PPC64_DTPREL16_HIGHERA 104 /* half16	(sym+add)@dtprel@highera */
+#define R_PPC64_DTPREL16_HIGHEST 105 /* half16	(sym+add)@dtprel@highest */
+#define R_PPC64_DTPREL16_HIGHESTA 106 /* half16	(sym+add)@dtprel@highesta */
+
+/* Keep this the last entry.  */
+#define R_PPC64_NUM		107
+
+/* PowerPC64 specific values for the Dyn d_tag field.  */
+#define DT_PPC64_GLINK  (DT_LOPROC + 0)
+#define DT_PPC64_OPD	(DT_LOPROC + 1)
+#define DT_PPC64_OPDSZ	(DT_LOPROC + 2)
+#define DT_PPC64_NUM    3
+
+
+/* ARM specific declarations */
+
+/* Processor specific flags for the ELF header e_flags field.  */
+#define EF_ARM_RELEXEC     0x01
+#define EF_ARM_HASENTRY    0x02
+#define EF_ARM_INTERWORK   0x04
+#define EF_ARM_APCS_26     0x08
+#define EF_ARM_APCS_FLOAT  0x10
+#define EF_ARM_PIC         0x20
+#define EF_ARM_ALIGN8      0x40		/* 8-bit structure alignment is in use */
+#define EF_ARM_NEW_ABI     0x80
+#define EF_ARM_OLD_ABI     0x100
+
+/* Other constants defined in the ARM ELF spec. version B-01.  */
+/* NB. These conflict with values defined above.  */
+#define EF_ARM_SYMSARESORTED	0x04
+#define EF_ARM_DYNSYMSUSESEGIDX 0x08
+#define EF_ARM_MAPSYMSFIRST	0x10
+#define EF_ARM_EABIMASK		0XFF000000
+
+#define EF_ARM_EABI_VERSION(flags) ((flags) & EF_ARM_EABIMASK)
+#define EF_ARM_EABI_UNKNOWN  0x00000000
+#define EF_ARM_EABI_VER1     0x01000000
+#define EF_ARM_EABI_VER2     0x02000000
+
+/* Additional symbol types for Thumb */
+#define STT_ARM_TFUNC      0xd
+
+/* ARM-specific values for sh_flags */
+#define SHF_ARM_ENTRYSECT  0x10000000   /* Section contains an entry point */
+#define SHF_ARM_COMDEF     0x80000000   /* Section may be multiply defined
+					   in the input to a link step */
+
+/* ARM-specific program header flags */
+#define PF_ARM_SB          0x10000000   /* Segment contains the location
+					   addressed by the static base */
+
+/* ARM relocs.  */
+#define R_ARM_NONE		0	/* No reloc */
+#define R_ARM_PC24		1	/* PC relative 26 bit branch */
+#define R_ARM_ABS32		2	/* Direct 32 bit  */
+#define R_ARM_REL32		3	/* PC relative 32 bit */
+#define R_ARM_PC13		4
+#define R_ARM_ABS16		5	/* Direct 16 bit */
+#define R_ARM_ABS12		6	/* Direct 12 bit */
+#define R_ARM_THM_ABS5		7
+#define R_ARM_ABS8		8	/* Direct 8 bit */
+#define R_ARM_SBREL32		9
+#define R_ARM_THM_PC22		10
+#define R_ARM_THM_PC8		11
+#define R_ARM_AMP_VCALL9	12
+#define R_ARM_SWI24		13
+#define R_ARM_THM_SWI8		14
+#define R_ARM_XPC25		15
+#define R_ARM_THM_XPC22		16
+#define R_ARM_COPY		20	/* Copy symbol at runtime */
+#define R_ARM_GLOB_DAT		21	/* Create GOT entry */
+#define R_ARM_JUMP_SLOT		22	/* Create PLT entry */
+#define R_ARM_RELATIVE		23	/* Adjust by program base */
+#define R_ARM_GOTOFF		24	/* 32 bit offset to GOT */
+#define R_ARM_GOTPC		25	/* 32 bit PC relative offset to GOT */
+#define R_ARM_GOT32		26	/* 32 bit GOT entry */
+#define R_ARM_PLT32		27	/* 32 bit PLT address */
+#define R_ARM_ALU_PCREL_7_0	32
+#define R_ARM_ALU_PCREL_15_8	33
+#define R_ARM_ALU_PCREL_23_15	34
+#define R_ARM_LDR_SBREL_11_0	35
+#define R_ARM_ALU_SBREL_19_12	36
+#define R_ARM_ALU_SBREL_27_20	37
+#define R_ARM_GNU_VTENTRY	100
+#define R_ARM_GNU_VTINHERIT	101
+#define R_ARM_THM_PC11		102	/* thumb unconditional branch */
+#define R_ARM_THM_PC9		103	/* thumb conditional branch */
+#define R_ARM_RXPC25		249
+#define R_ARM_RSBREL32		250
+#define R_ARM_THM_RPC22		251
+#define R_ARM_RREL32		252
+#define R_ARM_RABS22		253
+#define R_ARM_RPC24		254
+#define R_ARM_RBASE		255
+/* Keep this the last entry.  */
+#define R_ARM_NUM		256
+
+/* IA-64 specific declarations.  */
+
+/* Processor specific flags for the Ehdr e_flags field.  */
+#define EF_IA_64_MASKOS		0x0000000f	/* os-specific flags */
+#define EF_IA_64_ABI64		0x00000010	/* 64-bit ABI */
+#define EF_IA_64_ARCH		0xff000000	/* arch. version mask */
+
+/* Processor specific values for the Phdr p_type field.  */
+#define PT_IA_64_ARCHEXT	(PT_LOPROC + 0)	/* arch extension bits */
+#define PT_IA_64_UNWIND		(PT_LOPROC + 1)	/* ia64 unwind bits */
+#define PT_IA_64_HP_OPT_ANOT	(PT_LOOS + 0x12)
+#define PT_IA_64_HP_HSL_ANOT	(PT_LOOS + 0x13)
+#define PT_IA_64_HP_STACK	(PT_LOOS + 0x14)
+
+/* Processor specific flags for the Phdr p_flags field.  */
+#define PF_IA_64_NORECOV	0x80000000	/* spec insns w/o recovery */
+
+/* Processor specific values for the Shdr sh_type field.  */
+#define SHT_IA_64_EXT		(SHT_LOPROC + 0) /* extension bits */
+#define SHT_IA_64_UNWIND	(SHT_LOPROC + 1) /* unwind bits */
+
+/* Processor specific flags for the Shdr sh_flags field.  */
+#define SHF_IA_64_SHORT		0x10000000	/* section near gp */
+#define SHF_IA_64_NORECOV	0x20000000	/* spec insns w/o recovery */
+
+/* Processor specific values for the Dyn d_tag field.  */
+#define DT_IA_64_PLT_RESERVE	(DT_LOPROC + 0)
+#define DT_IA_64_NUM		1
+
+/* IA-64 relocations.  */
+#define R_IA64_NONE		0x00	/* none */
+#define R_IA64_IMM14		0x21	/* symbol + addend, add imm14 */
+#define R_IA64_IMM22		0x22	/* symbol + addend, add imm22 */
+#define R_IA64_IMM64		0x23	/* symbol + addend, mov imm64 */
+#define R_IA64_DIR32MSB		0x24	/* symbol + addend, data4 MSB */
+#define R_IA64_DIR32LSB		0x25	/* symbol + addend, data4 LSB */
+#define R_IA64_DIR64MSB		0x26	/* symbol + addend, data8 MSB */
+#define R_IA64_DIR64LSB		0x27	/* symbol + addend, data8 LSB */
+#define R_IA64_GPREL22		0x2a	/* @gprel(sym + add), add imm22 */
+#define R_IA64_GPREL64I		0x2b	/* @gprel(sym + add), mov imm64 */
+#define R_IA64_GPREL32MSB	0x2c	/* @gprel(sym + add), data4 MSB */
+#define R_IA64_GPREL32LSB	0x2d	/* @gprel(sym + add), data4 LSB */
+#define R_IA64_GPREL64MSB	0x2e	/* @gprel(sym + add), data8 MSB */
+#define R_IA64_GPREL64LSB	0x2f	/* @gprel(sym + add), data8 LSB */
+#define R_IA64_LTOFF22		0x32	/* @ltoff(sym + add), add imm22 */
+#define R_IA64_LTOFF64I		0x33	/* @ltoff(sym + add), mov imm64 */
+#define R_IA64_PLTOFF22		0x3a	/* @pltoff(sym + add), add imm22 */
+#define R_IA64_PLTOFF64I	0x3b	/* @pltoff(sym + add), mov imm64 */
+#define R_IA64_PLTOFF64MSB	0x3e	/* @pltoff(sym + add), data8 MSB */
+#define R_IA64_PLTOFF64LSB	0x3f	/* @pltoff(sym + add), data8 LSB */
+#define R_IA64_FPTR64I		0x43	/* @fptr(sym + add), mov imm64 */
+#define R_IA64_FPTR32MSB	0x44	/* @fptr(sym + add), data4 MSB */
+#define R_IA64_FPTR32LSB	0x45	/* @fptr(sym + add), data4 LSB */
+#define R_IA64_FPTR64MSB	0x46	/* @fptr(sym + add), data8 MSB */
+#define R_IA64_FPTR64LSB	0x47	/* @fptr(sym + add), data8 LSB */
+#define R_IA64_PCREL60B		0x48	/* @pcrel(sym + add), brl */
+#define R_IA64_PCREL21B		0x49	/* @pcrel(sym + add), ptb, call */
+#define R_IA64_PCREL21M		0x4a	/* @pcrel(sym + add), chk.s */
+#define R_IA64_PCREL21F		0x4b	/* @pcrel(sym + add), fchkf */
+#define R_IA64_PCREL32MSB	0x4c	/* @pcrel(sym + add), data4 MSB */
+#define R_IA64_PCREL32LSB	0x4d	/* @pcrel(sym + add), data4 LSB */
+#define R_IA64_PCREL64MSB	0x4e	/* @pcrel(sym + add), data8 MSB */
+#define R_IA64_PCREL64LSB	0x4f	/* @pcrel(sym + add), data8 LSB */
+#define R_IA64_LTOFF_FPTR22	0x52	/* @ltoff(@fptr(s+a)), imm22 */
+#define R_IA64_LTOFF_FPTR64I	0x53	/* @ltoff(@fptr(s+a)), imm64 */
+#define R_IA64_LTOFF_FPTR32MSB	0x54	/* @ltoff(@fptr(s+a)), data4 MSB */
+#define R_IA64_LTOFF_FPTR32LSB	0x55	/* @ltoff(@fptr(s+a)), data4 LSB */
+#define R_IA64_LTOFF_FPTR64MSB	0x56	/* @ltoff(@fptr(s+a)), data8 MSB */
+#define R_IA64_LTOFF_FPTR64LSB	0x57	/* @ltoff(@fptr(s+a)), data8 LSB */
+#define R_IA64_SEGREL32MSB	0x5c	/* @segrel(sym + add), data4 MSB */
+#define R_IA64_SEGREL32LSB	0x5d	/* @segrel(sym + add), data4 LSB */
+#define R_IA64_SEGREL64MSB	0x5e	/* @segrel(sym + add), data8 MSB */
+#define R_IA64_SEGREL64LSB	0x5f	/* @segrel(sym + add), data8 LSB */
+#define R_IA64_SECREL32MSB	0x64	/* @secrel(sym + add), data4 MSB */
+#define R_IA64_SECREL32LSB	0x65	/* @secrel(sym + add), data4 LSB */
+#define R_IA64_SECREL64MSB	0x66	/* @secrel(sym + add), data8 MSB */
+#define R_IA64_SECREL64LSB	0x67	/* @secrel(sym + add), data8 LSB */
+#define R_IA64_REL32MSB		0x6c	/* data 4 + REL */
+#define R_IA64_REL32LSB		0x6d	/* data 4 + REL */
+#define R_IA64_REL64MSB		0x6e	/* data 8 + REL */
+#define R_IA64_REL64LSB		0x6f	/* data 8 + REL */
+#define R_IA64_LTV32MSB		0x74	/* symbol + addend, data4 MSB */
+#define R_IA64_LTV32LSB		0x75	/* symbol + addend, data4 LSB */
+#define R_IA64_LTV64MSB		0x76	/* symbol + addend, data8 MSB */
+#define R_IA64_LTV64LSB		0x77	/* symbol + addend, data8 LSB */
+#define R_IA64_PCREL21BI	0x79	/* @pcrel(sym + add), 21bit inst */
+#define R_IA64_PCREL22		0x7a	/* @pcrel(sym + add), 22bit inst */
+#define R_IA64_PCREL64I		0x7b	/* @pcrel(sym + add), 64bit inst */
+#define R_IA64_IPLTMSB		0x80	/* dynamic reloc, imported PLT, MSB */
+#define R_IA64_IPLTLSB		0x81	/* dynamic reloc, imported PLT, LSB */
+#define R_IA64_COPY		0x84	/* copy relocation */
+#define R_IA64_SUB		0x85	/* Addend and symbol difference */
+#define R_IA64_LTOFF22X		0x86	/* LTOFF22, relaxable.  */
+#define R_IA64_LDXMOV		0x87	/* Use of LTOFF22X.  */
+#define R_IA64_TPREL14		0x91	/* @tprel(sym + add), imm14 */
+#define R_IA64_TPREL22		0x92	/* @tprel(sym + add), imm22 */
+#define R_IA64_TPREL64I		0x93	/* @tprel(sym + add), imm64 */
+#define R_IA64_TPREL64MSB	0x96	/* @tprel(sym + add), data8 MSB */
+#define R_IA64_TPREL64LSB	0x97	/* @tprel(sym + add), data8 LSB */
+#define R_IA64_LTOFF_TPREL22	0x9a	/* @ltoff(@tprel(s+a)), imm2 */
+#define R_IA64_DTPMOD64MSB	0xa6	/* @dtpmod(sym + add), data8 MSB */
+#define R_IA64_DTPMOD64LSB	0xa7	/* @dtpmod(sym + add), data8 LSB */
+#define R_IA64_LTOFF_DTPMOD22	0xaa	/* @ltoff(@dtpmod(sym + add)), imm22 */
+#define R_IA64_DTPREL14		0xb1	/* @dtprel(sym + add), imm14 */
+#define R_IA64_DTPREL22		0xb2	/* @dtprel(sym + add), imm22 */
+#define R_IA64_DTPREL64I	0xb3	/* @dtprel(sym + add), imm64 */
+#define R_IA64_DTPREL32MSB	0xb4	/* @dtprel(sym + add), data4 MSB */
+#define R_IA64_DTPREL32LSB	0xb5	/* @dtprel(sym + add), data4 LSB */
+#define R_IA64_DTPREL64MSB	0xb6	/* @dtprel(sym + add), data8 MSB */
+#define R_IA64_DTPREL64LSB	0xb7	/* @dtprel(sym + add), data8 LSB */
+#define R_IA64_LTOFF_DTPREL22	0xba	/* @ltoff(@dtprel(s+a)), imm22 */
+
+/* SH specific declarations */
+
+/* SH relocs.  */
+#define	R_SH_NONE		0
+#define	R_SH_DIR32		1
+#define	R_SH_REL32		2
+#define	R_SH_DIR8WPN		3
+#define	R_SH_IND12W		4
+#define	R_SH_DIR8WPL		5
+#define	R_SH_DIR8WPZ		6
+#define	R_SH_DIR8BP		7
+#define	R_SH_DIR8W		8
+#define	R_SH_DIR8L		9
+#define	R_SH_SWITCH16		25
+#define	R_SH_SWITCH32		26
+#define	R_SH_USES		27
+#define	R_SH_COUNT		28
+#define	R_SH_ALIGN		29
+#define	R_SH_CODE		30
+#define	R_SH_DATA		31
+#define	R_SH_LABEL		32
+#define	R_SH_SWITCH8		33
+#define	R_SH_GNU_VTINHERIT	34
+#define	R_SH_GNU_VTENTRY	35
+#define	R_SH_TLS_GD_32		144
+#define	R_SH_TLS_LD_32		145
+#define	R_SH_TLS_LDO_32		146
+#define	R_SH_TLS_IE_32		147
+#define	R_SH_TLS_LE_32		148
+#define	R_SH_TLS_DTPMOD32	149
+#define	R_SH_TLS_DTPOFF32	150
+#define	R_SH_TLS_TPOFF32	151
+#define	R_SH_GOT32		160
+#define	R_SH_PLT32		161
+#define	R_SH_COPY		162
+#define	R_SH_GLOB_DAT		163
+#define	R_SH_JMP_SLOT		164
+#define	R_SH_RELATIVE		165
+#define	R_SH_GOTOFF		166
+#define	R_SH_GOTPC		167
+/* Keep this the last entry.  */
+#define	R_SH_NUM		256
+
+/* Additional s390 relocs */
+
+#define R_390_NONE		0	/* No reloc.  */
+#define R_390_8			1	/* Direct 8 bit.  */
+#define R_390_12		2	/* Direct 12 bit.  */
+#define R_390_16		3	/* Direct 16 bit.  */
+#define R_390_32		4	/* Direct 32 bit.  */
+#define R_390_PC32		5	/* PC relative 32 bit.	*/
+#define R_390_GOT12		6	/* 12 bit GOT offset.  */
+#define R_390_GOT32		7	/* 32 bit GOT offset.  */
+#define R_390_PLT32		8	/* 32 bit PC relative PLT address.  */
+#define R_390_COPY		9	/* Copy symbol at runtime.  */
+#define R_390_GLOB_DAT		10	/* Create GOT entry.  */
+#define R_390_JMP_SLOT		11	/* Create PLT entry.  */
+#define R_390_RELATIVE		12	/* Adjust by program base.  */
+#define R_390_GOTOFF32		13	/* 32 bit offset to GOT.	 */
+#define R_390_GOTPC		14	/* 32 bit PC relative offset to GOT.  */
+#define R_390_GOT16		15	/* 16 bit GOT offset.  */
+#define R_390_PC16		16	/* PC relative 16 bit.	*/
+#define R_390_PC16DBL		17	/* PC relative 16 bit shifted by 1.  */
+#define R_390_PLT16DBL		18	/* 16 bit PC rel. PLT shifted by 1.  */
+#define R_390_PC32DBL		19	/* PC relative 32 bit shifted by 1.  */
+#define R_390_PLT32DBL		20	/* 32 bit PC rel. PLT shifted by 1.  */
+#define R_390_GOTPCDBL		21	/* 32 bit PC rel. GOT shifted by 1.  */
+#define R_390_64		22	/* Direct 64 bit.  */
+#define R_390_PC64		23	/* PC relative 64 bit.	*/
+#define R_390_GOT64		24	/* 64 bit GOT offset.  */
+#define R_390_PLT64		25	/* 64 bit PC relative PLT address.  */
+#define R_390_GOTENT		26	/* 32 bit PC rel. to GOT entry >> 1. */
+#define R_390_GOTOFF16		27	/* 16 bit offset to GOT. */
+#define R_390_GOTOFF64		28	/* 64 bit offset to GOT. */
+#define R_390_GOTPLT12		29	/* 12 bit offset to jump slot.	*/
+#define R_390_GOTPLT16		30	/* 16 bit offset to jump slot.	*/
+#define R_390_GOTPLT32		31	/* 32 bit offset to jump slot.	*/
+#define R_390_GOTPLT64		32	/* 64 bit offset to jump slot.	*/
+#define R_390_GOTPLTENT		33	/* 32 bit rel. offset to jump slot.  */
+#define R_390_PLTOFF16		34	/* 16 bit offset from GOT to PLT. */
+#define R_390_PLTOFF32		35	/* 32 bit offset from GOT to PLT. */
+#define R_390_PLTOFF64		36	/* 16 bit offset from GOT to PLT. */
+#define R_390_TLS_LOAD		37	/* Tag for load insn in TLS code.  */
+#define R_390_TLS_GDCALL	38	/* Tag for function call in general
+					   dynamic TLS code. */
+#define R_390_TLS_LDCALL	39	/* Tag for function call in local
+					   dynamic TLS code. */
+#define R_390_TLS_GD32		40	/* Direct 32 bit for general dynamic
+					   thread local data.  */
+#define R_390_TLS_GD64		41	/* Direct 64 bit for general dynamic
+					  thread local data.  */
+#define R_390_TLS_GOTIE12	42	/* 12 bit GOT offset for static TLS
+					   block offset.  */
+#define R_390_TLS_GOTIE32	43	/* 32 bit GOT offset for static TLS
+					   block offset.  */
+#define R_390_TLS_GOTIE64	44	/* 64 bit GOT offset for static TLS
+					   block offset. */
+#define R_390_TLS_LDM32		45	/* Direct 32 bit for local dynamic
+					   thread local data in LE code.  */
+#define R_390_TLS_LDM64		46	/* Direct 64 bit for local dynamic
+					   thread local data in LE code.  */
+#define R_390_TLS_IE32		47	/* 32 bit address of GOT entry for
+					   negated static TLS block offset.  */
+#define R_390_TLS_IE64		48	/* 64 bit address of GOT entry for
+					   negated static TLS block offset.  */
+#define R_390_TLS_IEENT		49	/* 32 bit rel. offset to GOT entry for
+					   negated static TLS block offset.  */
+#define R_390_TLS_LE32		50	/* 32 bit negated offset relative to
+					   static TLS block.  */
+#define R_390_TLS_LE64		51	/* 64 bit negated offset relative to
+					   static TLS block.  */
+#define R_390_TLS_LDO32		52	/* 32 bit offset relative to TLS
+					   block.  */
+#define R_390_TLS_LDO64		53	/* 64 bit offset relative to TLS
+					   block.  */
+#define R_390_TLS_DTPMOD	54	/* ID of module containing symbol.  */
+#define R_390_TLS_DTPOFF	55	/* Offset in TLS block.	 */
+#define R_390_TLS_TPOFF		56	/* Negated offset in static TLS
+					   block.  */
+#define R_390_20		57	/* Direct 20 bit.  */
+#define R_390_GOT20		58	/* 20 bit GOT offset.  */
+#define R_390_GOTPLT20		59	/* 20 bit offset to jump slot.  */
+#define R_390_TLS_GOTIE20	60	/* 20 bit GOT offset for static TLS
+					   block offset.  */
+/* Keep this the last entry.  */
+#define R_390_NUM		61
+
+
+/* CRIS relocations.  */
+#define R_CRIS_NONE		0
+#define R_CRIS_8		1
+#define R_CRIS_16		2
+#define R_CRIS_32		3
+#define R_CRIS_8_PCREL		4
+#define R_CRIS_16_PCREL		5
+#define R_CRIS_32_PCREL		6
+#define R_CRIS_GNU_VTINHERIT	7
+#define R_CRIS_GNU_VTENTRY	8
+#define R_CRIS_COPY		9
+#define R_CRIS_GLOB_DAT		10
+#define R_CRIS_JUMP_SLOT	11
+#define R_CRIS_RELATIVE		12
+#define R_CRIS_16_GOT		13
+#define R_CRIS_32_GOT		14
+#define R_CRIS_16_GOTPLT	15
+#define R_CRIS_32_GOTPLT	16
+#define R_CRIS_32_GOTREL	17
+#define R_CRIS_32_PLT_GOTREL	18
+#define R_CRIS_32_PLT_PCREL	19
+
+#define R_CRIS_NUM		20
+
+
+/* AMD x86-64 relocations.  */
+#define R_X86_64_NONE		0	/* No reloc */
+#define R_X86_64_64		1	/* Direct 64 bit  */
+#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
+#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
+#define R_X86_64_PLT32		4	/* 32 bit PLT address */
+#define R_X86_64_COPY		5	/* Copy symbol at runtime */
+#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
+#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
+#define R_X86_64_RELATIVE	8	/* Adjust by program base */
+#define R_X86_64_GOTPCREL	9	/* 32 bit signed PC relative
+					   offset to GOT */
+#define R_X86_64_32		10	/* Direct 32 bit zero extended */
+#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
+#define R_X86_64_16		12	/* Direct 16 bit zero extended */
+#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
+#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
+#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
+#define R_X86_64_DTPMOD64	16	/* ID of module containing symbol */
+#define R_X86_64_DTPOFF64	17	/* Offset in module's TLS block */
+#define R_X86_64_TPOFF64	18	/* Offset in initial TLS block */
+#define R_X86_64_TLSGD		19	/* 32 bit signed PC relative offset
+					   to two GOT entries for GD symbol */
+#define R_X86_64_TLSLD		20	/* 32 bit signed PC relative offset
+					   to two GOT entries for LD symbol */
+#define R_X86_64_DTPOFF32	21	/* Offset in TLS block */
+#define R_X86_64_GOTTPOFF	22	/* 32 bit signed PC relative offset
+					   to GOT entry for IE symbol */
+#define R_X86_64_TPOFF32	23	/* Offset in initial TLS block */
+
+#define R_X86_64_NUM		24
+
+
+/* AM33 relocations.  */
+#define R_MN10300_NONE		0	/* No reloc.  */
+#define R_MN10300_32		1	/* Direct 32 bit.  */
+#define R_MN10300_16		2	/* Direct 16 bit.  */
+#define R_MN10300_8		3	/* Direct 8 bit.  */
+#define R_MN10300_PCREL32	4	/* PC-relative 32-bit.  */
+#define R_MN10300_PCREL16	5	/* PC-relative 16-bit signed.  */
+#define R_MN10300_PCREL8	6	/* PC-relative 8-bit signed.  */
+#define R_MN10300_GNU_VTINHERIT	7	/* Ancient C++ vtable garbage... */
+#define R_MN10300_GNU_VTENTRY	8	/* ... collection annotation.  */
+#define R_MN10300_24		9	/* Direct 24 bit.  */
+#define R_MN10300_GOTPC32	10	/* 32-bit PCrel offset to GOT.  */
+#define R_MN10300_GOTPC16	11	/* 16-bit PCrel offset to GOT.  */
+#define R_MN10300_GOTOFF32	12	/* 32-bit offset from GOT.  */
+#define R_MN10300_GOTOFF24	13	/* 24-bit offset from GOT.  */
+#define R_MN10300_GOTOFF16	14	/* 16-bit offset from GOT.  */
+#define R_MN10300_PLT32		15	/* 32-bit PCrel to PLT entry.  */
+#define R_MN10300_PLT16		16	/* 16-bit PCrel to PLT entry.  */
+#define R_MN10300_GOT32		17	/* 32-bit offset to GOT entry.  */
+#define R_MN10300_GOT24		18	/* 24-bit offset to GOT entry.  */
+#define R_MN10300_GOT16		19	/* 16-bit offset to GOT entry.  */
+#define R_MN10300_COPY		20	/* Copy symbol at runtime.  */
+#define R_MN10300_GLOB_DAT	21	/* Create GOT entry.  */
+#define R_MN10300_JMP_SLOT	22	/* Create PLT entry.  */
+#define R_MN10300_RELATIVE	23	/* Adjust by program base.  */
+
+#define R_MN10300_NUM		24
+
+
+/* M32R relocs.  */
+#define R_M32R_NONE		0	/* No reloc. */
+#define R_M32R_16		1	/* Direct 16 bit. */
+#define R_M32R_32		2	/* Direct 32 bit. */
+#define R_M32R_24		3	/* Direct 24 bit. */
+#define R_M32R_10_PCREL		4	/* PC relative 10 bit shifted. */
+#define R_M32R_18_PCREL		5	/* PC relative 18 bit shifted. */
+#define R_M32R_26_PCREL		6	/* PC relative 26 bit shifted. */
+#define R_M32R_HI16_ULO		7	/* High 16 bit with unsigned low. */
+#define R_M32R_HI16_SLO		8	/* High 16 bit with signed low. */
+#define R_M32R_LO16		9	/* Low 16 bit. */
+#define R_M32R_SDA16		10	/* 16 bit offset in SDA. */
+#define R_M32R_GNU_VTINHERIT	11
+#define R_M32R_GNU_VTENTRY	12
+/* M32R relocs use SHT_RELA.  */
+#define R_M32R_16_RELA		33	/* Direct 16 bit. */
+#define R_M32R_32_RELA		34	/* Direct 32 bit. */
+#define R_M32R_24_RELA		35	/* Direct 24 bit. */
+#define R_M32R_10_PCREL_RELA	36	/* PC relative 10 bit shifted. */
+#define R_M32R_18_PCREL_RELA	37	/* PC relative 18 bit shifted. */
+#define R_M32R_26_PCREL_RELA	38	/* PC relative 26 bit shifted. */
+#define R_M32R_HI16_ULO_RELA	39	/* High 16 bit with unsigned low */
+#define R_M32R_HI16_SLO_RELA	40	/* High 16 bit with signed low */
+#define R_M32R_LO16_RELA	41	/* Low 16 bit */
+#define R_M32R_SDA16_RELA	42	/* 16 bit offset in SDA */
+#define R_M32R_RELA_GNU_VTINHERIT	43
+#define R_M32R_RELA_GNU_VTENTRY	44
+#define R_M32R_REL32		45	/* PC relative 32 bit */
+
+#define R_M32R_GOT24		48	/* 24 bit GOT entry */
+#define R_M32R_26_PLTREL	49	/* 26 bit PC relative to PLT shifted */
+#define R_M32R_COPY		50	/* Copy symbol at runtime */
+#define R_M32R_GLOB_DAT		51	/* Create GOT entry */
+#define R_M32R_JMP_SLOT		52	/* Create PLT entry */
+#define R_M32R_RELATIVE		53	/* Adjust by program base */
+#define R_M32R_GOTOFF		54	/* 24 bit offset to GOT */
+#define R_M32R_GOTPC24		55	/* 24 bit PC relative offset to GOT */
+#define R_M32R_GOT16_HI_ULO	56	/* High 16 bit GOT entry with unsigned
+					   low */
+#define R_M32R_GOT16_HI_SLO	57	/* High 16 bit GOT entry with signed
+					   low */
+#define R_M32R_GOT16_LO		58	/* Low 16 bit GOT entry */
+#define R_M32R_GOTPC_HI_ULO	59	/* High 16 bit PC relative offset to
+					   GOT with unsigned low */
+#define R_M32R_GOTPC_HI_SLO	60	/* High 16 bit PC relative offset to
+					   GOT with signed low */
+#define R_M32R_GOTPC_LO		61	/* Low 16 bit PC relative offset to
+					   GOT */
+#define R_M32R_GOTOFF_HI_ULO	62	/* High 16 bit offset to GOT
+					   with unsigned low */
+#define R_M32R_GOTOFF_HI_SLO	63	/* High 16 bit offset to GOT
+					   with signed low */
+#define R_M32R_GOTOFF_LO	64	/* Low 16 bit offset to GOT */
+#define R_M32R_NUM		256	/* Keep this the last entry. */
+
+
+//__END_DECLS
+
+#endif	/* elf.h */
diff -Naur linux/include/fcntl.h linux_working/linux-0.01-master/include/fcntl.h
--- linux/include/fcntl.h	1991-09-17 20:42:39.000000000 +0530
+++ linux_working/linux-0.01-master/include/fcntl.h	2013-09-18 12:48:30.000000000 +0530
@@ -28,6 +28,9 @@
 #define F_GETLK		5	/* not implemented */
 #define F_SETLK		6
 #define F_SETLKW	7
+#define F_GETLK64	12
+#define F_SETLK64	13
+#define F_SETLKW64	14
 
 /* for F_[GET|SET]FL */
 #define FD_CLOEXEC	1	/* actually anything with low bit set goes */
diff -Naur linux/include/linux/config.h linux_working/linux-0.01-master/include/linux/config.h
--- linux/include/linux/config.h	1991-09-17 20:29:37.000000000 +0530
+++ linux_working/linux-0.01-master/include/linux/config.h	2013-09-18 12:48:30.000000000 +0530
@@ -9,13 +9,7 @@
  * Don't make this bigger without making sure that there are enough page
  * directory entries (boot/head.s)
  */
-#if	defined(LINUS_HD)
 #define HIGH_MEMORY (0x800000)
-#elif	defined(LASU_HD)
-#define HIGH_MEMORY (0x400000)
-#else
-#error "must define hd"
-#endif
 
 /* End of buffer memory. Must be 0xA0000, or > 0x100000, 4096-byte aligned */
 #if (HIGH_MEMORY>=0x600000)
@@ -25,13 +19,7 @@
 #endif
 
 /* Root device at bootup. */
-#if	defined(LINUS_HD)
-#define ROOT_DEV 0x306
-#elif	defined(LASU_HD)
-#define ROOT_DEV 0x302
-#else
-#error "must define HD"
-#endif
+#define ROOT_DEV 0x301
 
 /*
  * HD type. If 2, put 2 structures with a comma. If just 1, put
@@ -42,12 +30,7 @@
  * more than 8 heads, but that is what the bios-listings seem to imply. I
  * just love not having a manual.
  */
-#if	defined(LASU_HD)
-#define HD_TYPE { 7,35,915,65536,920,0 }
-#elif	defined(LINUS_HD)
-#define HD_TYPE { 5,17,980,300,980,0 },{ 5,17,980,300,980,0 }
-#else
-#error "must define a hard-disk type"
-#endif
+
+#define HD_TYPE { 4,20,1024,0,4,0 }
 
 #endif
diff -Naur linux/include/linux/hdreg.h linux_working/linux-0.01-master/include/linux/hdreg.h
--- linux/include/linux/hdreg.h	1991-07-11 02:14:37.000000000 +0530
+++ linux_working/linux-0.01-master/include/linux/hdreg.h	2013-09-18 12:48:30.000000000 +0530
@@ -14,24 +14,12 @@
  * but easier. We don't use BIOS for anything else, why should
  * we get HD-type from it? Get these values from Reference Guide.
  */
-
-#if HARD_DISK_TYPE == 17
-#define _CYL	977
-#define _HEAD	5
-#define __WPCOM	300
-#define _LZONE	977
-#define _SECT	17
-#define _CTL	0
-#elif HARD_DISK_TYPE == 18
-#define _CYL	977
-#define _HEAD	7
-#define __WPCOM	(-1)
-#define _LZONE	977
-#define _SECT	17
+#define _CYL	1024
+#define _HEAD	4
+#define __WPCOM	(-1)		/*not used ?*/
+#define _LZONE	1024		/*same as _CYL ?*/
+#define _SECT	20
 #define _CTL	0
-#else
-#error Define HARD_DISK_TYPE and parameters, add your own entries as well
-#endif
 
 /* Controller wants just wp-com/4 */
 #if __WPCOM >= 0
@@ -55,14 +43,14 @@
 #define HD_CMD		0x3f6
 
 /* Bits of HD_STATUS */
-#define ERR_STAT	0x01
-#define INDEX_STAT	0x02
-#define ECC_STAT	0x04	/* Corrected error */
-#define DRQ_STAT	0x08
-#define SEEK_STAT	0x10
-#define WRERR_STAT	0x20
-#define READY_STAT	0x40
-#define BUSY_STAT	0x80
+#define ERR_STAT	0x01	/*0 => no error */
+#define INDEX_STAT	0x02	/*not used in new controller*/
+#define ECC_STAT	0x04	/*1 => Corrected error */
+#define DRQ_STAT	0x08	/*0=> controller not waiting for data. 1 => waiting*/
+#define SEEK_STAT	0x10	/*0=> searching. 1=> end of search. waiting for read or write*/
+#define WRERR_STAT	0x20	/*1=> write error.*/
+#define READY_STAT	0x40	/*1=> ready*/
+#define BUSY_STAT	0x80	/*1 => busy*/
 
 /* Values for HD_COMMAND */
 #define WIN_RESTORE		0x10
@@ -78,7 +66,7 @@
 /* Bits for HD_ERROR */
 #define MARK_ERR	0x01	/* Bad address mark ? */
 #define TRK0_ERR	0x02	/* couldn't find track 0 */
-#define ABRT_ERR	0x04	/* ? */
+#define ABRT_ERR	0x04	/* command stopped */
 #define ID_ERR		0x10	/* ? */
 #define ECC_ERR		0x40	/* ? */
 #define	BBD_ERR		0x80	/* ? */
diff -Naur linux/include/linux/kernel.h linux_working/linux-0.01-master/include/linux/kernel.h
--- linux/include/linux/kernel.h	1991-07-10 01:00:30.000000000 +0530
+++ linux_working/linux-0.01-master/include/linux/kernel.h	2013-09-18 12:48:30.000000000 +0530
@@ -2,7 +2,7 @@
  * 'kernel.h' contains some often-used function prototypes etc
  */
 void verify_area(void * addr,int count);
-volatile void panic(const char * str);
+void panic(const char * str);
 int printf(const char * fmt, ...);
 int printk(const char * fmt, ...);
 int tty_write(unsigned ch,char * buf,int count);
diff -Naur linux/include/linux/sched.h linux_working/linux-0.01-master/include/linux/sched.h
--- linux/include/linux/sched.h	1991-09-17 19:00:22.000000000 +0530
+++ linux_working/linux-0.01-master/include/linux/sched.h	2013-09-18 12:48:30.000000000 +0530
@@ -167,64 +167,67 @@
  */
 #define switch_to(n) {\
 struct {long a,b;} __tmp; \
-__asm__("cmpl %%ecx,_current\n\t" \
+__asm__ __volatile__("cmpl %%ecx,current\n\t" \
 	"je 1f\n\t" \
-	"xchgl %%ecx,_current\n\t" \
+	"xchgl %%ecx,current\n\t" \
 	"movw %%dx,%1\n\t" \
-	"ljmp %0\n\t" \
+	"ljmp *%0\n\t" \
 	"cmpl %%ecx,%2\n\t" \
 	"jne 1f\n\t" \
 	"clts\n" \
-	"1:" \
+	"1:\n\t" \
 	::"m" (*&__tmp.a),"m" (*&__tmp.b), \
 	"m" (last_task_used_math),"d" _TSS(n),"c" ((long) task[n])); \
 }
 
 #define PAGE_ALIGN(n) (((n)+0xfff)&0xfffff000)
 
-#define _set_base(addr,base) \
-__asm__("movw %%dx,%0\n\t" \
+#define _set_base(addr,base) do { unsigned long __pr; \
+__asm__ __volatile__ ("movw %%dx,%1\n\t" \
 	"rorl $16,%%edx\n\t" \
-	"movb %%dl,%1\n\t" \
-	"movb %%dh,%2" \
-	::"m" (*((addr)+2)), \
-	  "m" (*((addr)+4)), \
-	  "m" (*((addr)+7)), \
-	  "d" (base) \
-	:"dx")
+	"movb %%dl,%2\n\t" \
+	"movb %%dh,%3" \
+	:"=&d" (__pr) \
+	:"m" (*((addr)+2)), \
+	 "m" (*((addr)+4)), \
+	 "m" (*((addr)+7)), \
+         "0" (base) \
+        ); } while(0)
 
-#define _set_limit(addr,limit) \
-__asm__("movw %%dx,%0\n\t" \
+#define _set_limit(addr,limit) do { unsigned long __lr; \
+__asm__ __volatile__ ("movw %%dx,%1\n\t" \
 	"rorl $16,%%edx\n\t" \
-	"movb %1,%%dh\n\t" \
+	"movb %2,%%dh\n\t" \
 	"andb $0xf0,%%dh\n\t" \
 	"orb %%dh,%%dl\n\t" \
-	"movb %%dl,%1" \
-	::"m" (*(addr)), \
-	  "m" (*((addr)+6)), \
-	  "d" (limit) \
-	:"dx")
+	"movb %%dl,%2" \
+	:"=&d" (__lr) \
+	:"m" (*(addr)), \
+	 "m" (*((addr)+6)), \
+	 "0" (limit) \
+        ); } while(0)
 
 #define set_base(ldt,base) _set_base( ((char *)&(ldt)) , base )
 #define set_limit(ldt,limit) _set_limit( ((char *)&(ldt)) , (limit-1)>>12 )
 
-#define _get_base(addr) ({\
-unsigned long __base; \
-__asm__("movb %3,%%dh\n\t" \
-	"movb %2,%%dl\n\t" \
-	"shll $16,%%edx\n\t" \
-	"movw %1,%%dx" \
-	:"=d" (__base) \
-	:"m" (*((addr)+2)), \
-	 "m" (*((addr)+4)), \
-	 "m" (*((addr)+7))); \
-__base;})
-
+static inline unsigned long _get_base(char * addr)
+{
+	unsigned long __base;
+	__asm__("movb %3,%%dh\n\t"
+		"movb %2,%%dl\n\t"
+		"shll $16,%%edx\n\t"
+		"movw %1,%%dx"
+		:"=&d" (__base)
+		:"m" (*((addr)+2)),
+		 "m" (*((addr)+4)),
+		 "m" (*((addr)+7)));
+	return __base;
+}
 #define get_base(ldt) _get_base( ((char *)&(ldt)) )
 
 #define get_limit(segment) ({ \
 unsigned long __limit; \
-__asm__("lsll %1,%0\n\tincl %0":"=r" (__limit):"r" (segment)); \
+__asm__ __volatile__("lsll %1,%0\n\tincl %0":"=r" (__limit):"r" (segment)); \
 __limit;})
 
 #endif
diff -Naur linux/include/linux/sys.h linux_working/linux-0.01-master/include/linux/sys.h
--- linux/include/linux/sys.h	1991-09-08 18:05:09.000000000 +0530
+++ linux_working/linux-0.01-master/include/linux/sys.h	2013-09-18 12:48:30.000000000 +0530
@@ -16,7 +16,7 @@
 extern int sys_chmod();
 extern int sys_chown();
 extern int sys_break();
-extern int sys_stat();
+extern int sys_oldstat();
 extern int sys_lseek();
 extern int sys_getpid();
 extern int sys_mount();
@@ -26,7 +26,7 @@
 extern int sys_stime();
 extern int sys_ptrace();
 extern int sys_alarm();
-extern int sys_fstat();
+extern int sys_oldfstat();
 extern int sys_pause();
 extern int sys_utime();
 extern int sys_stty();
@@ -57,7 +57,7 @@
 extern int sys_mpx();
 extern int sys_setpgid();
 extern int sys_ulimit();
-extern int sys_uname();
+extern int sys_oldolduname();
 extern int sys_umask();
 extern int sys_chroot();
 extern int sys_ustat();
@@ -65,16 +65,80 @@
 extern int sys_getppid();
 extern int sys_getpgrp();
 extern int sys_setsid();
+extern int sys_stat();
+extern int sys_lstat();
+extern int sys_fstat();
+extern int sys_uname();
+extern int sys_getdents();
+extern int sys_stat64();
+extern int sys_lstat64();
+extern int sys_fstat64();
+extern int sys_getdents64();
+extern int sys_fcntl64();
+extern int sys_null();	/* not implemented sys_call */
 
 fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,
 sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,
 sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,
-sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,
+sys_chown, sys_break, sys_oldstat, sys_lseek, sys_getpid, sys_mount,
 sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,
-sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,
+sys_oldfstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,
 sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,
 sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,
 sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,
 sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,
-sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,
-sys_getpgrp,sys_setsid};
+sys_oldolduname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,
+sys_getpgrp,sys_setsid, sys_null /*67*/,sys_null,sys_null,
+
+/* 70 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 80 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 90 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 100 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_stat,sys_lstat,sys_fstat,sys_null,
+/* 110 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 120 */sys_null,sys_null,sys_uname,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 130 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 140 */sys_null,sys_getdents,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 150 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 160 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 170 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 180 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 190 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_stat64,sys_lstat64,sys_fstat64,sys_null,sys_null,
+/* 200 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 210 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 220 */sys_getdents64,sys_fcntl64,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 230 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 240 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 250 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 260 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 270 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 280 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 290 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 300 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null,
+/* 310 */sys_null,sys_null,sys_null,sys_null,sys_null,
+sys_null,sys_null,sys_null,sys_null,sys_null
+};
+
diff -Naur linux/include/stdint.h linux_working/linux-0.01-master/include/stdint.h
--- linux/include/stdint.h	1970-01-01 05:30:00.000000000 +0530
+++ linux_working/linux-0.01-master/include/stdint.h	2013-09-18 12:48:30.000000000 +0530
@@ -0,0 +1,320 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ *	ISO C99: 7.18 Integer types <stdint.h>
+ */
+
+#ifndef _STDINT_H
+#define _STDINT_H	1
+
+//#include <features.h>
+#include <bits/wchar.h>
+#include <bits/wordsize.h>
+
+/* Exact integral types.  */
+
+/* Signed.  */
+
+/* There is some amount of overlap with <sys/types.h> as known by inet code */
+#ifndef __int8_t_defined
+# define __int8_t_defined
+typedef signed char		int8_t;
+typedef short int		int16_t;
+typedef int			int32_t;
+# if __WORDSIZE == 64
+typedef long int		int64_t;
+# else
+__extension__
+typedef long long int		int64_t;
+# endif
+#endif
+
+/* Unsigned.  */
+typedef unsigned char		uint8_t;
+typedef unsigned short int	uint16_t;
+#ifndef __uint32_t_defined
+typedef unsigned int		uint32_t;
+# define __uint32_t_defined
+#endif
+#if __WORDSIZE == 64
+typedef unsigned long int	uint64_t;
+#else
+__extension__
+typedef unsigned long long int	uint64_t;
+#endif
+
+
+/* Small types.  */
+
+/* Signed.  */
+typedef signed char		int_least8_t;
+typedef short int		int_least16_t;
+typedef int			int_least32_t;
+#if __WORDSIZE == 64
+typedef long int		int_least64_t;
+#else
+__extension__
+typedef long long int		int_least64_t;
+#endif
+
+/* Unsigned.  */
+typedef unsigned char		uint_least8_t;
+typedef unsigned short int	uint_least16_t;
+typedef unsigned int		uint_least32_t;
+#if __WORDSIZE == 64
+typedef unsigned long int	uint_least64_t;
+#else
+__extension__
+typedef unsigned long long int	uint_least64_t;
+#endif
+
+
+/* Fast types.  */
+
+/* Signed.  */
+typedef signed char		int_fast8_t;
+#if __WORDSIZE == 64
+typedef long int		int_fast16_t;
+typedef long int		int_fast32_t;
+typedef long int		int_fast64_t;
+#else
+typedef int			int_fast16_t;
+typedef int			int_fast32_t;
+__extension__
+typedef long long int		int_fast64_t;
+#endif
+
+/* Unsigned.  */
+typedef unsigned char		uint_fast8_t;
+#if __WORDSIZE == 64
+typedef unsigned long int	uint_fast16_t;
+typedef unsigned long int	uint_fast32_t;
+typedef unsigned long int	uint_fast64_t;
+#else
+typedef unsigned int		uint_fast16_t;
+typedef unsigned int		uint_fast32_t;
+__extension__
+typedef unsigned long long int	uint_fast64_t;
+#endif
+
+
+/* Types for `void *' pointers.  */
+#if __WORDSIZE == 64
+# ifndef __intptr_t_defined
+typedef long int		intptr_t;
+#  define __intptr_t_defined
+# endif
+typedef unsigned long int	uintptr_t;
+#else
+# ifndef __intptr_t_defined
+typedef int			intptr_t;
+#  define __intptr_t_defined
+# endif
+typedef unsigned int		uintptr_t;
+#endif
+
+
+/* Largest integral types.  */
+#if __WORDSIZE == 64
+typedef long int		intmax_t;
+typedef unsigned long int	uintmax_t;
+#else
+__extension__
+typedef long long int		intmax_t;
+__extension__
+typedef unsigned long long int	uintmax_t;
+#endif
+
+
+/* The ISO C99 standard specifies that in C++ implementations these
+   macros should only be defined if explicitly requested.  */
+#if !defined __cplusplus || defined __STDC_LIMIT_MACROS
+
+# if __WORDSIZE == 64
+#  define __INT64_C(c)	c ## L
+#  define __UINT64_C(c)	c ## UL
+# else
+#  define __INT64_C(c)	c ## LL
+#  define __UINT64_C(c)	c ## ULL
+# endif
+
+/* Limits of integral types.  */
+
+/* Minimum of signed integral types.  */
+# define INT8_MIN		(-128)
+# define INT16_MIN		(-32767-1)
+# define INT32_MIN		(-2147483647-1)
+# define INT64_MIN		(-__INT64_C(9223372036854775807)-1)
+/* Maximum of signed integral types.  */
+# define INT8_MAX		(127)
+# define INT16_MAX		(32767)
+# define INT32_MAX		(2147483647)
+# define INT64_MAX		(__INT64_C(9223372036854775807))
+
+/* Maximum of unsigned integral types.  */
+# define UINT8_MAX		(255)
+# define UINT16_MAX		(65535)
+# define UINT32_MAX		(4294967295U)
+# define UINT64_MAX		(__UINT64_C(18446744073709551615))
+
+
+/* Minimum of signed integral types having a minimum size.  */
+# define INT_LEAST8_MIN		(-128)
+# define INT_LEAST16_MIN	(-32767-1)
+# define INT_LEAST32_MIN	(-2147483647-1)
+# define INT_LEAST64_MIN	(-__INT64_C(9223372036854775807)-1)
+/* Maximum of signed integral types having a minimum size.  */
+# define INT_LEAST8_MAX		(127)
+# define INT_LEAST16_MAX	(32767)
+# define INT_LEAST32_MAX	(2147483647)
+# define INT_LEAST64_MAX	(__INT64_C(9223372036854775807))
+
+/* Maximum of unsigned integral types having a minimum size.  */
+# define UINT_LEAST8_MAX	(255)
+# define UINT_LEAST16_MAX	(65535)
+# define UINT_LEAST32_MAX	(4294967295U)
+# define UINT_LEAST64_MAX	(__UINT64_C(18446744073709551615))
+
+
+/* Minimum of fast signed integral types having a minimum size.  */
+# define INT_FAST8_MIN		(-128)
+# if __WORDSIZE == 64
+#  define INT_FAST16_MIN	(-9223372036854775807L-1)
+#  define INT_FAST32_MIN	(-9223372036854775807L-1)
+# else
+#  define INT_FAST16_MIN	(-2147483647-1)
+#  define INT_FAST32_MIN	(-2147483647-1)
+# endif
+# define INT_FAST64_MIN		(-__INT64_C(9223372036854775807)-1)
+/* Maximum of fast signed integral types having a minimum size.  */
+# define INT_FAST8_MAX		(127)
+# if __WORDSIZE == 64
+#  define INT_FAST16_MAX	(9223372036854775807L)
+#  define INT_FAST32_MAX	(9223372036854775807L)
+# else
+#  define INT_FAST16_MAX	(2147483647)
+#  define INT_FAST32_MAX	(2147483647)
+# endif
+# define INT_FAST64_MAX		(__INT64_C(9223372036854775807))
+
+/* Maximum of fast unsigned integral types having a minimum size.  */
+# define UINT_FAST8_MAX		(255)
+# if __WORDSIZE == 64
+#  define UINT_FAST16_MAX	(18446744073709551615UL)
+#  define UINT_FAST32_MAX	(18446744073709551615UL)
+# else
+#  define UINT_FAST16_MAX	(4294967295U)
+#  define UINT_FAST32_MAX	(4294967295U)
+# endif
+# define UINT_FAST64_MAX	(__UINT64_C(18446744073709551615))
+
+
+/* Values to test for integral types holding `void *' pointer.  */
+# if __WORDSIZE == 64
+#  define INTPTR_MIN		(-9223372036854775807L-1)
+#  define INTPTR_MAX		(9223372036854775807L)
+#  define UINTPTR_MAX		(18446744073709551615UL)
+# else
+#  define INTPTR_MIN		(-2147483647-1)
+#  define INTPTR_MAX		(2147483647)
+#  define UINTPTR_MAX		(4294967295U)
+# endif
+
+
+/* Minimum for largest signed integral type.  */
+# define INTMAX_MIN		(-__INT64_C(9223372036854775807)-1)
+/* Maximum for largest signed integral type.  */
+# define INTMAX_MAX		(__INT64_C(9223372036854775807))
+
+/* Maximum for largest unsigned integral type.  */
+# define UINTMAX_MAX		(__UINT64_C(18446744073709551615))
+
+
+/* Limits of other integer types.  */
+
+/* Limits of `ptrdiff_t' type.  */
+# if __WORDSIZE == 64
+#  define PTRDIFF_MIN		(-9223372036854775807L-1)
+#  define PTRDIFF_MAX		(9223372036854775807L)
+# else
+#  define PTRDIFF_MIN		(-2147483647-1)
+#  define PTRDIFF_MAX		(2147483647)
+# endif
+
+/* Limits of `sig_atomic_t'.  */
+# define SIG_ATOMIC_MIN		(-2147483647-1)
+# define SIG_ATOMIC_MAX		(2147483647)
+
+/* Limit of `size_t' type.  */
+# if __WORDSIZE == 64
+#  define SIZE_MAX		(18446744073709551615UL)
+# else
+#  define SIZE_MAX		(4294967295U)
+# endif
+
+/* Limits of `wchar_t'.  */
+# ifndef WCHAR_MIN
+/* These constants might also be defined in <wchar.h>.  */
+#  define WCHAR_MIN		__WCHAR_MIN
+#  define WCHAR_MAX		__WCHAR_MAX
+# endif
+
+/* Limits of `wint_t'.  */
+# define WINT_MIN		(0u)
+# define WINT_MAX		(4294967295u)
+
+#endif	/* C++ && limit macros */
+
+
+/* The ISO C99 standard specifies that in C++ implementations these
+   should only be defined if explicitly requested.  */
+#if !defined __cplusplus || defined __STDC_CONSTANT_MACROS
+
+/* Signed.  */
+# define INT8_C(c)	c
+# define INT16_C(c)	c
+# define INT32_C(c)	c
+# if __WORDSIZE == 64
+#  define INT64_C(c)	c ## L
+# else
+#  define INT64_C(c)	c ## LL
+# endif
+
+/* Unsigned.  */
+# define UINT8_C(c)	c ## U
+# define UINT16_C(c)	c ## U
+# define UINT32_C(c)	c ## U
+# if __WORDSIZE == 64
+#  define UINT64_C(c)	c ## UL
+# else
+#  define UINT64_C(c)	c ## ULL
+# endif
+
+/* Maximal type.  */
+# if __WORDSIZE == 64
+#  define INTMAX_C(c)	c ## L
+#  define UINTMAX_C(c)	c ## UL
+# else
+#  define INTMAX_C(c)	c ## LL
+#  define UINTMAX_C(c)	c ## ULL
+# endif
+
+#endif	/* C++ && constant macros */
+
+#endif /* stdint.h */
diff -Naur linux/include/string.h linux_working/linux-0.01-master/include/string.h
--- linux/include/string.h	1991-09-17 20:34:09.000000000 +0530
+++ linux_working/linux-0.01-master/include/string.h	2013-09-18 12:48:30.000000000 +0530
@@ -26,18 +26,21 @@
  
 extern inline char * strcpy(char * dest,const char *src)
 {
-__asm__("cld\n"
+int d0, d1, d2;
+__asm__ __volatile__("cld\n\t"
 	"1:\tlodsb\n\t"
 	"stosb\n\t"
 	"testb %%al,%%al\n\t"
 	"jne 1b"
-	::"S" (src),"D" (dest):"si","di","ax");
+	: "=&S" (d0), "=&D" (d1), "=&a" (d2)
+	:"0" (src),"1" (dest) : "memory");
 return dest;
 }
 
 extern inline char * strncpy(char * dest,const char *src,int count)
 {
-__asm__("cld\n"
+int d0, d1, d2, d3;
+__asm__ __volatile__("cld\n\t"
 	"1:\tdecl %2\n\t"
 	"js 2f\n\t"
 	"lodsb\n\t"
@@ -47,13 +50,15 @@
 	"rep\n\t"
 	"stosb\n"
 	"2:"
-	::"S" (src),"D" (dest),"c" (count):"si","di","ax","cx");
+	: "=&S" (d0), "=&D" (d1), "=&c" (d2), "=&a" (d3)
+	:"0" (src),"1" (dest),"2" (count) : "memory");
 return dest;
 }
 
 extern inline char * strcat(char * dest,const char * src)
 {
-__asm__("cld\n\t"
+int d0, d1, d2, d3;
+__asm__ __volatile__("cld\n\t"
 	"repne\n\t"
 	"scasb\n\t"
 	"decl %1\n"
@@ -61,17 +66,19 @@
 	"stosb\n\t"
 	"testb %%al,%%al\n\t"
 	"jne 1b"
-	::"S" (src),"D" (dest),"a" (0),"c" (0xffffffff):"si","di","ax","cx");
+	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
+	: "0" (src), "1" (dest), "2" (0), "3" (0xffffffffu):"memory");
 return dest;
 }
 
 extern inline char * strncat(char * dest,const char * src,int count)
 {
-__asm__("cld\n\t"
+int d0, d1, d2, d3;
+__asm__ __volatile__("cld\n\t"
 	"repne\n\t"
 	"scasb\n\t"
 	"decl %1\n\t"
-	"movl %4,%3\n"
+	"movl %8,%3\n"
 	"1:\tdecl %3\n\t"
 	"js 2f\n\t"
 	"lodsb\n\t"
@@ -80,15 +87,17 @@
 	"jne 1b\n"
 	"2:\txorl %2,%2\n\t"
 	"stosb"
-	::"S" (src),"D" (dest),"a" (0),"c" (0xffffffff),"g" (count)
-	:"si","di","ax","cx");
+	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
+	: "0" (src),"1" (dest),"2" (0),"3" (0xffffffffu), "g" (count)
+	: "memory");
 return dest;
 }
 
 extern inline int strcmp(const char * cs,const char * ct)
 {
-register int __res __asm__("ax");
-__asm__("cld\n"
+int d0, d1;
+register int __res;
+__asm__ __volatile__("cld\n\t"
 	"1:\tlodsb\n\t"
 	"scasb\n\t"
 	"jne 2f\n\t"
@@ -96,18 +105,20 @@
 	"jne 1b\n\t"
 	"xorl %%eax,%%eax\n\t"
 	"jmp 3f\n"
-	"2:\tmovl $1,%%eax\n\t"
-	"jl 3f\n\t"
-	"negl %%eax\n"
+	"2:\tsbbl %%eax,%%eax\n\t"
+	"orb $1,%%al\n"
 	"3:"
-	:"=a" (__res):"D" (cs),"S" (ct):"si","di");
+	:"=a" (__res), "=&S" (d0), "=&D" (d1)
+	:"1" (cs),"2" (ct)
+	:"memory");
 return __res;
 }
 
 extern inline int strncmp(const char * cs,const char * ct,int count)
 {
-register int __res __asm__("ax");
-__asm__("cld\n"
+register int __res;
+int d0, d1, d2;
+__asm__ __volatile__("cld\n\t"
 	"1:\tdecl %3\n\t"
 	"js 2f\n\t"
 	"lodsb\n\t"
@@ -117,18 +128,20 @@
 	"jne 1b\n"
 	"2:\txorl %%eax,%%eax\n\t"
 	"jmp 4f\n"
-	"3:\tmovl $1,%%eax\n\t"
-	"jl 4f\n\t"
-	"negl %%eax\n"
+	"3:\tsbbl %%eax,%%eax\n\t"
+	"orb $1,%%al\n"
 	"4:"
-	:"=a" (__res):"D" (cs),"S" (ct),"c" (count):"si","di","cx");
+	:"=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2)
+	:"1" (cs),"2" (ct),"3" (count)
+	:"memory");
 return __res;
 }
 
-extern inline char * strchr(const char * s,char c)
+extern inline char * strchr(const char * s,int c)
 {
-register char * __res __asm__("ax");
-__asm__("cld\n\t"
+int d0;
+register char * __res;
+__asm__ __volatile__(
 	"movb %%al,%%ah\n"
 	"1:\tlodsb\n\t"
 	"cmpb %%ah,%%al\n\t"
@@ -138,29 +151,33 @@
 	"movl $1,%1\n"
 	"2:\tmovl %1,%0\n\t"
 	"decl %0"
-	:"=a" (__res):"S" (s),"0" (c):"si");
+	:"=a" (__res), "=&S" (d0)
+	:"1" (s),"0" (c)
+	:"memory");
 return __res;
 }
 
-extern inline char * strrchr(const char * s,char c)
+extern inline char * strrchr(const char * s,int c)
 {
-register char * __res __asm__("dx");
-__asm__("cld\n\t"
+int d0, d1;
+register char * __res;
+__asm__ __volatile__("cld\n\t"
 	"movb %%al,%%ah\n"
 	"1:\tlodsb\n\t"
 	"cmpb %%ah,%%al\n\t"
 	"jne 2f\n\t"
-	"movl %%esi,%0\n\t"
-	"decl %0\n"
+	"leal -1(%%esi),%0\n"
 	"2:\ttestb %%al,%%al\n\t"
 	"jne 1b"
-	:"=d" (__res):"0" (0),"S" (s),"a" (c):"ax","si");
+	:"=g" (__res), "=&S" (d0), "=&a" (d1)
+	:"0" (0),"1" (s),"2" (c)
+	:"memory");
 return __res;
 }
 
 extern inline int strspn(const char * cs, const char * ct)
 {
-register char * __res __asm__("si");
+register char * __res;// __asm__("si");
 __asm__("cld\n\t"
 	"movl %4,%%edi\n\t"
 	"repne\n\t"
@@ -178,13 +195,13 @@
 	"je 1b\n"
 	"2:\tdecl %0"
 	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
-	:"ax","cx","dx","di");
+	:/*"ax","cx",*/"dx","di"); /* TODO : constraint may be wrong*/
 return __res-cs;
 }
 
 extern inline int strcspn(const char * cs, const char * ct)
 {
-register char * __res __asm__("si");
+register char * __res;// __asm__("si");
 __asm__("cld\n\t"
 	"movl %4,%%edi\n\t"
 	"repne\n\t"
@@ -202,13 +219,13 @@
 	"jne 1b\n"
 	"2:\tdecl %0"
 	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
-	:"ax","cx","dx","di");
+	:/*"ax","cx",*/"dx","di"); /* TODO : constraint may be wrong*/
 return __res-cs;
 }
 
 extern inline char * strpbrk(const char * cs,const char * ct)
 {
-register char * __res __asm__("si");
+register char * __res;// __asm__("si");
 __asm__("cld\n\t"
 	"movl %4,%%edi\n\t"
 	"repne\n\t"
@@ -229,13 +246,13 @@
 	"2:\txorl %0,%0\n"
 	"3:"
 	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
-	:"ax","cx","dx","di");
+	:/*"ax","cx",*/"dx","di");/* TODO : constraint may be wrong*/
 return __res;
 }
 
 extern inline char * strstr(const char * cs,const char * ct)
 {
-register char * __res __asm__("ax");
+register char * __res;// __asm__("ax");
 __asm__("cld\n\t" \
 	"movl %4,%%edi\n\t"
 	"repne\n\t"
@@ -256,19 +273,22 @@
 	"xorl %%eax,%%eax\n\t"
 	"2:"
 	:"=a" (__res):"0" (0),"c" (0xffffffff),"S" (cs),"g" (ct)
-	:"cx","dx","di","si");
+	:/*"cx",*/"dx","di"/*,"si"*/); /* TODO : constraint may be wrong*/
 return __res;
 }
 
 extern inline int strlen(const char * s)
 {
-register int __res __asm__("cx");
-__asm__("cld\n\t"
+int d0;
+register int __res;
+__asm__ __volatile__("cld\n\t"
 	"repne\n\t"
 	"scasb\n\t"
 	"notl %0\n\t"
 	"decl %0"
-	:"=c" (__res):"D" (s),"a" (0),"0" (0xffffffff):"di");
+	:"=c" (__res), "=&D" (d0)
+	:"1" (s),"a" (0), "0" (0xffffffffu)
+	:"memory");
 return __res;
 }
 
@@ -276,7 +296,7 @@
 
 extern inline char * strtok(char * s,const char * ct)
 {
-register char * __res __asm__("si");
+register char * __res;// __asm__("si");
 __asm__("testl %1,%1\n\t"
 	"jne 1f\n\t"
 	"testl %0,%0\n\t"
@@ -329,40 +349,46 @@
 	"8:"
 	:"=b" (__res),"=S" (___strtok)
 	:"0" (___strtok),"1" (s),"g" (ct)
-	:"ax","cx","dx","di");
+	:"ax","cx","dx","di"); /* TODO : constraint may be wrong*/
 return __res;
 }
 
 extern inline void * memcpy(void * dest,const void * src, int n)
 {
-__asm__("cld\n\t"
+int d0,d1,d2;
+__asm__ __volatile("cld\n\t"
 	"rep\n\t"
 	"movsb"
-	::"c" (n),"S" (src),"D" (dest)
-	:"cx","si","di");
+	:"=&c" (d0), "=&S" (d1), "=&D" (d2)
+	:"0" (n),"1" (src),"2" (dest)
+	:"memory");
 return dest;
 }
 
 extern inline void * memmove(void * dest,const void * src, int n)
 {
-if (dest<src)
-__asm__("cld\n\t"
-	"rep\n\t"
-	"movsb"
-	::"c" (n),"S" (src),"D" (dest)
-	:"cx","si","di");
-else
-__asm__("std\n\t"
-	"rep\n\t"
-	"movsb"
-	::"c" (n),"S" (src+n-1),"D" (dest+n-1)
-	:"cx","si","di");
-return dest;
+	int d0, d1, d2;
+
+	if (dest < src) {
+		memcpy(dest,src,n);
+	} else {
+		__asm__ __volatile__(
+			"std\n\t"
+			"rep\n\t"
+			"movsb\n\t"
+			"cld"
+			: "=&c" (d0), "=&S" (d1), "=&D" (d2)
+			:"0" (n),
+			 "1" (n-1+(const char *)src),
+			 "2" (n-1+(char *)dest)
+			:"memory");
+	}
+	return dest;
 }
 
 extern inline int memcmp(const void * cs,const void * ct,int count)
 {
-register int __res __asm__("ax");
+register int __res;// __asm__("ax");
 __asm__("cld\n\t"
 	"repe\n\t"
 	"cmpsb\n\t"
@@ -372,33 +398,37 @@
 	"negl %%eax\n"
 	"1:"
 	:"=a" (__res):"0" (0),"D" (cs),"S" (ct),"c" (count)
-	:"si","di","cx");
+	/*:"si","di","cx"*/); /* TODO : constraint may be wrong*/
 return __res;
 }
 
 extern inline void * memchr(const void * cs,char c,int count)
 {
-register void * __res __asm__("di");
+int d0;
+register void * __res;
 if (!count)
 	return NULL;
-__asm__("cld\n\t"
+__asm__ __volatile__("cld\n\t"
 	"repne\n\t"
 	"scasb\n\t"
 	"je 1f\n\t"
 	"movl $1,%0\n"
 	"1:\tdecl %0"
-	:"=D" (__res):"a" (c),"D" (cs),"c" (count)
-	:"cx");
+	:"=D" (__res), "=&c" (d0)
+	:"a" (c),"0" (cs),"1" (count)
+	:"memory");
 return __res;
 }
 
-extern inline void * memset(void * s,char c,int count)
+extern inline void * memset(void * s,int c,int count)
 {
-__asm__("cld\n\t"
+int d0, d1;
+__asm__ __volatile__("cld\n\t"
 	"rep\n\t"
 	"stosb"
-	::"a" (c),"D" (s),"c" (count)
-	:"cx","di");
+	: "=&c" (d0), "=&D" (d1)
+	:"a" (c),"1" (s),"0" (count)
+	:"memory");
 return s;
 }
 
diff -Naur linux/include/sys/stat.h linux_working/linux-0.01-master/include/sys/stat.h
--- linux/include/sys/stat.h	1991-09-17 20:32:48.000000000 +0530
+++ linux_working/linux-0.01-master/include/sys/stat.h	2013-09-18 12:48:30.000000000 +0530
@@ -2,19 +2,63 @@
 #define _SYS_STAT_H
 
 #include <sys/types.h>
+#include <stdint.h>
 
 struct stat {
-	dev_t	st_dev;
-	ino_t	st_ino;
-	umode_t	st_mode;
-	nlink_t	st_nlink;
-	uid_t	st_uid;
-	gid_t	st_gid;
-	dev_t	st_rdev;
-	off_t	st_size;
-	time_t	st_atime;
-	time_t	st_mtime;
-	time_t	st_ctime;
+	uint16_t	st_dev;
+	uint16_t	__pad1;
+	unsigned long	st_ino;
+	uint16_t	st_mode;
+	uint16_t	st_nlink;
+	uint16_t	st_uid;
+	uint16_t	st_gid;
+	uint16_t	st_rdev;
+	uint16_t	__pad2;
+	unsigned long	st_size;
+	unsigned long	st_blksize;
+	unsigned long	st_blocks;
+	time_t		st_atime;
+	unsigned long	__unused1;
+	time_t		st_mtime;
+	unsigned long	__unused2;
+	time_t		st_ctime;
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+	unsigned long	__unused5;
+};
+
+struct stat64 {
+	uint16_t	st_dev;
+	unsigned char	__pad0[10];
+
+#define STAT64_HAS_BROKEN_ST_INO	1
+	unsigned long	__st_ino;
+
+	uint32_t	st_mode;
+	uint32_t	st_nlink;
+
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+
+	uint16_t	st_rdev;
+	unsigned char	__pad3[10];
+
+__extension__	long long	st_size __attribute__((__packed__));
+	unsigned long	st_blksize;
+
+	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
+	unsigned long	__pad4;		/* future possible st_blocks high bits */
+
+	time_t		st_atime;
+	unsigned long	__pad5;
+
+	time_t		st_mtime;
+	unsigned long	__pad6;
+
+	time_t		st_ctime;
+	unsigned long	__pad7;		/* will be high 32 bits of ctime someday */
+
+__extension__	unsigned long long	st_ino __attribute__((__packed__));
 };
 
 #define S_IFMT  00170000
@@ -49,10 +93,10 @@
 #define S_IXOTH 00001
 
 extern int chmod(const char *_path, mode_t mode);
-extern int fstat(int fildes, struct stat *stat_buf);
+extern int fstat64(int fildes, struct stat64 *stat_buf);
 extern int mkdir(const char *_path, mode_t mode);
 extern int mkfifo(const char *_path, mode_t mode);
-extern int stat(const char *filename, struct stat *stat_buf);
+extern int stat64(const char *filename, struct stat64 *stat_buf);
 extern mode_t umask(mode_t mask);
 
 #endif
diff -Naur linux/include/sys/utsname.h linux_working/linux-0.01-master/include/sys/utsname.h
--- linux/include/sys/utsname.h	1991-09-17 20:33:23.000000000 +0530
+++ linux_working/linux-0.01-master/include/sys/utsname.h	2013-09-18 12:48:30.000000000 +0530
@@ -1,16 +1,35 @@
-#ifndef _SYS_UTSNAME_H
-#define _SYS_UTSNAME_H
+#ifndef	_SYS_UTSNAME_H
+#define	_SYS_UTSNAME_H	1
 
-#include <sys/types.h>
+/* Length of the entries in `struct utsname' is 65.  */
+#define _UTSNAME_LENGTH 65
+#define _UTSNAME_NODENAME_LENGTH _UTSNAME_LENGTH
+
+/* Linux provides as additional information in the `struct utsname'
+   the name of the current domain.  Define _UTSNAME_DOMAIN_LENGTH
+   to a value != 0 to activate this entry.  */
+#define _UTSNAME_DOMAIN_LENGTH _UTSNAME_LENGTH
 
 struct utsname {
-	char sysname[9];
-	char nodename[9];
-	char release[9];
-	char version[9];
-	char machine[9];
+  /* Name of the implementation of the operating system.  */
+  char sysname[_UTSNAME_LENGTH];
+
+  /* Name of this node on the network.  */
+  char nodename[_UTSNAME_NODENAME_LENGTH];
+
+  /* Current release level of this implementation.  */
+  char release[_UTSNAME_LENGTH];
+  /* Current version level of this release.  */
+  char version[_UTSNAME_LENGTH];
+
+  /* Name of the hardware type the system is running on.  */
+  char machine[_UTSNAME_LENGTH];
+
+  /* Name of the domain of this node on the network.  */
+  char domainname[_UTSNAME_DOMAIN_LENGTH];
 };
 
-extern int uname(struct utsname * utsbuf);
+extern int uname (struct utsname *__name);
+
 
 #endif
diff -Naur linux/include/unistd.h linux_working/linux-0.01-master/include/unistd.h
--- linux/include/unistd.h	1991-09-17 20:42:39.000000000 +0530
+++ linux_working/linux-0.01-master/include/unistd.h	2013-09-18 12:48:30.000000000 +0530
@@ -54,6 +54,7 @@
 #include <sys/times.h>
 #include <sys/utsname.h>
 #include <utime.h>
+#include <dirent.h>
 
 #ifdef __LIBRARY__
 
@@ -75,7 +76,7 @@
 #define __NR_chmod	15
 #define __NR_chown	16
 #define __NR_break	17
-#define __NR_stat	18
+#define __NR_oldstat	18
 #define __NR_lseek	19
 #define __NR_getpid	20
 #define __NR_mount	21
@@ -85,7 +86,7 @@
 #define __NR_stime	25
 #define __NR_ptrace	26
 #define __NR_alarm	27
-#define __NR_fstat	28
+#define __NR_oldfstat	28
 #define __NR_pause	29
 #define __NR_utime	30
 #define __NR_stty	31
@@ -116,14 +117,24 @@
 #define __NR_mpx	56
 #define __NR_setpgid	57
 #define __NR_ulimit	58
-#define __NR_uname	59
+#define __NR_oldolduname 59
 #define __NR_umask	60
 #define __NR_chroot	61
 #define __NR_ustat	62
 #define __NR_dup2	63
 #define __NR_getppid	64
 #define __NR_getpgrp	65
-#define __NR_setsid	66
+#define __NR_setsid		66
+#define __NR_stat		106
+#define __NR_lstat		107
+#define __NR_fstat		108
+#define __NR_uname		122
+#define __NR_getdents	141
+#define __NR_stat64		195
+#define __NR_ltat64		196
+#define __NR_fstat64	197
+#define __NR_getdents64	220
+#define __NR_fcntl64	221
 
 #define _syscall0(type,name) \
 type name(void) \
@@ -198,10 +209,10 @@
 int execl(const char * pathname, char * arg0, ...);
 int execlp(const char * file, char * arg0, ...);
 int execle(const char * pathname, char * arg0, ...);
-volatile void exit(int status);
-volatile void _exit(int status);
+void exit(int status);
+void _exit(int status);
 int fcntl(int fildes, int cmd, ...);
-int fork(void);
+//int fork(void);
 int getpid(void);
 int getuid(void);
 int geteuid(void);
@@ -215,7 +226,7 @@
 int mount(const char * specialfile, const char * dir, int rwflag);
 int nice(int val);
 int open(const char * filename, int flag, ...);
-int pause(void);
+//int pause(void);
 int pipe(int * fildes);
 int read(int fildes, char * buf, off_t count);
 int setpgrp(void);
@@ -223,10 +234,10 @@
 int setuid(uid_t uid);
 int setgid(gid_t gid);
 void (*signal(int sig, void (*fn)(int)))(int);
-int stat(const char * filename, struct stat * stat_buf);
-int fstat(int fildes, struct stat * stat_buf);
+int stat64(const char * filename, struct stat64 * stat_buf);
+int fstat64(int fildes, struct stat64 * stat_buf);
 int stime(time_t * tptr);
-int sync(void);
+//int sync(void);
 time_t time(time_t * tloc);
 time_t times(struct tms * tbuf);
 int ulimit(int cmd, long limit);
@@ -243,5 +254,7 @@
 int getppid(void);
 pid_t getpgrp(void);
 pid_t setsid(void);
+int getdents(unsigned int fd, struct dirent *dirp, unsigned int count);
+int getdents64(unsigned int fd, struct dirent64 *dirp, unsigned int count);
 
 #endif
diff -Naur linux/init/main.c linux_working/linux-0.01-master/init/main.c
--- linux/init/main.c	1991-09-13 02:33:24.000000000 +0530
+++ linux_working/linux-0.01-master/init/main.c	2013-09-18 12:48:30.000000000 +0530
@@ -76,7 +76,7 @@
 	startup_time = kernel_mktime(&time);
 }
 
-void main(void)		/* This really IS void, no error here. */
+int main(void)		/* This really IS void, no error here. */
 {			/* The startup routine assumes (well, ...) this */
 /*
  * Interrupts are still disabled. Do necessary setups, then
@@ -101,6 +101,8 @@
  * task can run, and if not we return here.
  */
 	for(;;) pause();
+
+	return 0;
 }
 
 static int printf(const char *fmt, ...)
@@ -114,16 +116,14 @@
 	return i;
 }
 
-static char * argv[] = { "-",NULL };
-static char * envp[] = { "HOME=/usr/root", NULL };
+static char * argv[] = { "/bin/sh",NULL };
+static char * envp[] = { "HOME=/root","PATH=/bin","PWD=/", NULL };
 
 void init(void)
 {
 	int i,j;
 
 	setup();
-	if (!fork())
-		_exit(execve("/bin/update",NULL,NULL));
 	(void) open("/dev/tty0",O_RDWR,0);
 	(void) dup(0);
 	(void) dup(0);
diff -Naur linux/kernel/asm.s linux_working/linux-0.01-master/kernel/asm.s
--- linux/kernel/asm.s	1991-07-09 04:59:33.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/asm.s	2013-09-18 12:48:30.000000000 +0530
@@ -5,13 +5,13 @@
  * the fpu must be properly saved/resored. This hasn't been tested.
  */
 
-.globl _divide_error,_debug,_nmi,_int3,_overflow,_bounds,_invalid_op
-.globl _device_not_available,_double_fault,_coprocessor_segment_overrun
-.globl _invalid_TSS,_segment_not_present,_stack_segment
-.globl _general_protection,_coprocessor_error,_reserved
+.globl divide_error,debug,nmi,int3,overflow,bounds,invalid_op
+.globl device_not_available,double_fault,coprocessor_segment_overrun
+.globl invalid_TSS,segment_not_present,stack_segment
+.globl general_protection,coprocessor_error,reserved
 
-_divide_error:
-	pushl $_do_divide_error
+divide_error:
+	pushl $do_divide_error
 no_error_code:
 	xchgl %eax,(%esp)
 	pushl %ebx
@@ -44,69 +44,69 @@
 	popl %eax
 	iret
 
-_debug:
-	pushl $_do_int3		# _do_debug
+debug:
+	pushl $do_int3		# _do_debug
 	jmp no_error_code
 
-_nmi:
-	pushl $_do_nmi
+nmi:
+	pushl $do_nmi
 	jmp no_error_code
 
-_int3:
-	pushl $_do_int3
+int3:
+	pushl $do_int3
 	jmp no_error_code
 
-_overflow:
-	pushl $_do_overflow
+overflow:
+	pushl $do_overflow
 	jmp no_error_code
 
-_bounds:
-	pushl $_do_bounds
+bounds:
+	pushl $do_bounds
 	jmp no_error_code
 
-_invalid_op:
-	pushl $_do_invalid_op
+invalid_op:
+	pushl $do_invalid_op
 	jmp no_error_code
 
 math_emulate:
 	popl %eax
-	pushl $_do_device_not_available
+	pushl $do_device_not_available
 	jmp no_error_code
-_device_not_available:
+device_not_available:
 	pushl %eax
 	movl %cr0,%eax
 	bt $2,%eax			# EM (math emulation bit)
 	jc math_emulate
 	clts				# clear TS so that we can use math
-	movl _current,%eax
-	cmpl _last_task_used_math,%eax
+	movl current,%eax
+	cmpl last_task_used_math,%eax
 	je 1f				# shouldn't happen really ...
 	pushl %ecx
 	pushl %edx
 	push %ds
 	movl $0x10,%eax
 	mov %ax,%ds
-	call _math_state_restore
+	call math_state_restore
 	pop %ds
 	popl %edx
 	popl %ecx
 1:	popl %eax
 	iret
 
-_coprocessor_segment_overrun:
-	pushl $_do_coprocessor_segment_overrun
+coprocessor_segment_overrun:
+	pushl $do_coprocessor_segment_overrun
 	jmp no_error_code
 
-_reserved:
-	pushl $_do_reserved
+reserved:
+	pushl $do_reserved
 	jmp no_error_code
 
-_coprocessor_error:
-	pushl $_do_coprocessor_error
+coprocessor_error:
+	pushl $do_coprocessor_error
 	jmp no_error_code
 
-_double_fault:
-	pushl $_do_double_fault
+double_fault:
+	pushl $do_double_fault
 error_code:
 	xchgl %eax,4(%esp)		# error code <-> %eax
 	xchgl %ebx,(%esp)		# &function <-> %ebx
@@ -139,19 +139,19 @@
 	popl %eax
 	iret
 
-_invalid_TSS:
-	pushl $_do_invalid_TSS
+invalid_TSS:
+	pushl $do_invalid_TSS
 	jmp error_code
 
-_segment_not_present:
-	pushl $_do_segment_not_present
+segment_not_present:
+	pushl $do_segment_not_present
 	jmp error_code
 
-_stack_segment:
-	pushl $_do_stack_segment
+stack_segment:
+	pushl $do_stack_segment
 	jmp error_code
 
-_general_protection:
-	pushl $_do_general_protection
+general_protection:
+	pushl $do_general_protection
 	jmp error_code
 
diff -Naur linux/kernel/console.c linux_working/linux-0.01-master/kernel/console.c
--- linux/kernel/console.c	1991-09-07 21:16:27.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/console.c	2013-09-18 12:48:30.000000000 +0530
@@ -71,59 +71,72 @@
 		pos += columns<<1;
 		scr_end += columns<<1;
 		if (scr_end>SCREEN_END) {
-			__asm__("cld\n\t"
+			
+			int d0,d1,d2,d3;
+			__asm__ __volatile("cld\n\t"
 				"rep\n\t"
 				"movsl\n\t"
-				"movl _columns,%1\n\t"
+				"movl %[columns],%1\n\t"
 				"rep\n\t"
 				"stosw"
-				::"a" (0x0720),
-				"c" ((lines-1)*columns>>1),
-				"D" (SCREEN_START),
-				"S" (origin)
-				:"cx","di","si");
+				:"=&a" (d0), "=&c" (d1), "=&D" (d2), "=&S" (d3)
+				:"0" (0x0720),
+				 "1" ((lines-1)*columns>>1),
+				 "2" (SCREEN_START),
+				 "3" (origin),
+				 [columns] "r" (columns)
+				:"memory");
+
 			scr_end -= origin-SCREEN_START;
 			pos -= origin-SCREEN_START;
 			origin = SCREEN_START;
 		} else {
-			__asm__("cld\n\t"
+			int d0,d1,d2;
+			__asm__ __volatile("cld\n\t"
 				"rep\n\t"
 				"stosl"
-				::"a" (0x07200720),
-				"c" (columns>>1),
-				"D" (scr_end-(columns<<1))
-				:"cx","di");
+				:"=&a" (d0), "=&c" (d1), "=&D" (d2) 
+				:"0" (0x07200720),
+				"1" (columns>>1),
+				"2" (scr_end-(columns<<1))
+				:"memory");
 		}
 		set_origin();
 	} else {
-		__asm__("cld\n\t"
+		int d0,d1,d2,d3;
+		__asm__ __volatile__("cld\n\t"
 			"rep\n\t"
 			"movsl\n\t"
-			"movl _columns,%%ecx\n\t"
+			"movl %[columns],%%ecx\n\t"
 			"rep\n\t"
 			"stosw"
-			::"a" (0x0720),
-			"c" ((bottom-top-1)*columns>>1),
-			"D" (origin+(columns<<1)*top),
-			"S" (origin+(columns<<1)*(top+1))
-			:"cx","di","si");
+			:"=&a" (d0), "=&c" (d1), "=&D" (d2), "=&S" (d3)
+			:"0" (0x0720),
+			"1" ((bottom-top-1)*columns>>1),
+			"2" (origin+(columns<<1)*top),
+			"3" (origin+(columns<<1)*(top+1)),
+			[columns] "r" (columns)
+			:"memory");
 	}
 }
 
 static void scrdown(void)
 {
-	__asm__("std\n\t"
+	int d0,d1,d2,d3;
+	__asm__ __volatile__("std\n\t"
 		"rep\n\t"
 		"movsl\n\t"
 		"addl $2,%%edi\n\t"	/* %edi has been decremented by 4 */
-		"movl _columns,%%ecx\n\t"
+		"movl %[columns],%%ecx\n\t"
 		"rep\n\t"
 		"stosw"
-		::"a" (0x0720),
-		"c" ((bottom-top-1)*columns>>1),
-		"D" (origin+(columns<<1)*bottom-4),
-		"S" (origin+(columns<<1)*(bottom-1)-4)
-		:"ax","cx","di","si");
+		:"=&a" (d0), "=&c" (d1), "=&D" (d2), "=&S" (d3)
+		:"0" (0x0720),
+		"1" ((bottom-top-1)*columns>>1),
+		"2" (origin+(columns<<1)*bottom-4),
+		"3" (origin+(columns<<1)*(bottom-1)-4),
+		[columns] "r" (columns)
+		:"memory");
 }
 
 static void lf(void)
@@ -163,8 +176,8 @@
 
 static void csi_J(int par)
 {
-	long count __asm__("cx");
-	long start __asm__("di");
+	long count;
+	long start;
 
 	switch (par) {
 		case 0:	/* erase from cursor to end of display */
@@ -182,18 +195,19 @@
 		default:
 			return;
 	}
-	__asm__("cld\n\t"
+	int d0,d1,d2;
+	__asm__ __volatile__("cld\n\t"
 		"rep\n\t"
 		"stosw\n\t"
-		::"c" (count),
-		"D" (start),"a" (0x0720)
-		:"cx","di");
+		:"=&c" (d0), "=&D" (d1), "=&a" (d2)
+		:"0" (count),"1" (start),"2" (0x0720)
+		:"memory");
 }
 
 static void csi_K(int par)
 {
-	long count __asm__("cx");
-	long start __asm__("di");
+	long count;
+	long start;
 
 	switch (par) {
 		case 0:	/* erase from cursor to end of line */
@@ -213,12 +227,13 @@
 		default:
 			return;
 	}
-	__asm__("cld\n\t"
+	int d0,d1,d2;
+	__asm__ __volatile__("cld\n\t"
 		"rep\n\t"
 		"stosw\n\t"
-		::"c" (count),
-		"D" (start),"a" (0x0720)
-		:"cx","di");
+		:"=&c" (d0), "=&D" (d1), "=&a" (d2)
+		:"0" (count),"1" (start),"2" (0x0720)
+		:"memory");
 }
 
 void csi_m(void)
@@ -385,10 +400,10 @@
 						pos -= columns<<1;
 						lf();
 					}
-					__asm__("movb _attr,%%ah\n\t"
+					__asm__("movb attr,%%ah\n\t"
 						"movw %%ax,%1\n\t"
 						::"a" (c),"m" (*(short *)pos)
-						:"ax");
+						/*:"ax"*/);
 					pos += 2;
 					x++;
 				} else if (c==27)
@@ -438,7 +453,7 @@
 					par[npar]=0;
 				npar=0;
 				state=3;
-				if (ques=(c=='?'))
+				if ((ques=(c=='?')))
 					break;
 			case 3:
 				if (c==';' && npar<NPAR-1) {
diff -Naur linux/kernel/fork.c linux_working/linux-0.01-master/kernel/fork.c
--- linux/kernel/fork.c	1991-09-17 18:00:50.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/fork.c	2013-09-18 12:48:30.000000000 +0530
@@ -70,7 +70,11 @@
 	p = (struct task_struct *) get_free_page();
 	if (!p)
 		return -EAGAIN;
+#if 0 /* This statement breaks *p memory (gcc 4.4.5). */
 	*p = *current;	/* NOTE! this doesn't copy the supervisor stack */
+#else
+	memcpy(p, current, sizeof(struct task_struct));
+#endif
 	p->state = TASK_RUNNING;
 	p->pid = last_pid;
 	p->father = current->pid;
@@ -109,7 +113,7 @@
 		return -EAGAIN;
 	}
 	for (i=0; i<NR_OPEN;i++)
-		if (f=p->filp[i])
+		if ((f=p->filp[i]))
 			f->f_count++;
 	if (current->pwd)
 		current->pwd->i_count++;
diff -Naur linux/kernel/hd.c linux_working/linux-0.01-master/kernel/hd.c
--- linux/kernel/hd.c	1991-09-17 20:35:21.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/hd.c	2013-09-18 12:48:30.000000000 +0530
@@ -50,9 +50,9 @@
 } request[NR_REQUEST];
 
 #define IN_ORDER(s1,s2) \
-((s1)->hd<(s2)->hd || (s1)->hd==(s2)->hd && \
-((s1)->cyl<(s2)->cyl || (s1)->cyl==(s2)->cyl && \
-((s1)->head<(s2)->head || (s1)->head==(s2)->head && \
+(((s1)->hd<(s2)->hd || (s1)->hd==(s2)->hd) && \
+(((s1)->cyl<(s2)->cyl || (s1)->cyl==(s2)->cyl) && \
+(((s1)->head<(s2)->head || (s1)->head==(s2)->head) && \
 ((s1)->sector<(s2)->sector))))
 
 static struct hd_request * this_request = NULL;
@@ -66,10 +66,10 @@
 void hd_init(void);
 
 #define port_read(port,buf,nr) \
-__asm__("cld;rep;insw"::"d" (port),"D" (buf),"c" (nr):"cx","di")
+__asm__("cld;rep;insw"::"d" (port),"D" (buf),"c" (nr)/*:"cx","di"*/)
 
 #define port_write(port,buf,nr) \
-__asm__("cld;rep;outsw"::"d" (port),"S" (buf),"c" (nr):"cx","si")
+__asm__("cld;rep;outsw"::"d" (port),"S" (buf),"c" (nr)/*:"cx","si"*/)
 
 extern void hd_interrupt(void);
 
@@ -192,7 +192,8 @@
 	outb_p(sect,++port);
 	outb_p(cyl,++port);
 	outb_p(cyl>>8,++port);
-	outb_p(0xA0|(drive<<4)|head,++port);
+	/*0xB0 for slave, 0xA0 for master*/
+	outb_p(0xB0|(drive<<4)|head,++port);
 	outb(cmd,++port);
 }
 
@@ -205,7 +206,7 @@
 			break;
 	i = inb(HD_STATUS);
 	i &= BUSY_STAT | READY_STAT | SEEK_STAT;
-	if (i == READY_STAT | SEEK_STAT)
+	if (i == (READY_STAT | SEEK_STAT))
 		return(0);
 	printk("HD controller times out\n\r");
 	return(1);
@@ -221,7 +222,7 @@
 	for(i = 0; i < 10000 && drive_busy(); i++) /* nothing */;
 	if (drive_busy())
 		printk("HD-controller still busy\n\r");
-	if((i = inb(ERR_STAT)) != 1)
+	if((i = inb(HD_STATUS)) & ERR_STAT)
 		printk("HD-controller reset failed: %02x\n\r",i);
 }
 
@@ -256,11 +257,18 @@
 		bad_rw_intr();
 		return;
 	}
-	port_read(HD_DATA,this_request->bh->b_data+
-		512*(this_request->nsector&1),256);
-	this_request->errors = 0;
-	if (--this_request->nsector)
+	
+	if (this_request->nsector==2){
+		this_request->nsector--;
+		port_read(HD_DATA,this_request->bh->b_data,256);
+	}
+	else{
+		port_read(HD_DATA,this_request->bh->b_data+512,256);
 		return;
+	}
+
+	this_request->errors = 0;
+
 	this_request->bh->b_uptodate = 1;
 	this_request->bh->b_dirt = 0;
 	wake_up(&wait_for_request);
diff -Naur linux/kernel/keyboard.s linux_working/linux-0.01-master/kernel/keyboard.s
--- linux/kernel/keyboard.s	1991-08-30 02:44:34.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/keyboard.s	2013-09-18 12:48:30.000000000 +0530
@@ -3,7 +3,7 @@
  */
 
 .text
-.globl _keyboard_interrupt
+.globl keyboard_interrupt
 
 /*
  * these are for the keyboard read functions
@@ -24,7 +24,7 @@
  *  keyboard scan-code and converts it into the appropriate
  *  ascii character(s).
  */
-_keyboard_interrupt:
+keyboard_interrupt:
 	pushl %eax
 	pushl %ebx
 	pushl %ecx
@@ -34,13 +34,13 @@
 	movl $0x10,%eax
 	mov %ax,%ds
 	mov %ax,%es
-	xorl %al,%al		/* %eax is scan code */
+	xor %al,%al		/* %eax is scan code */
 	inb $0x60,%al
 	cmpb $0xe0,%al
 	je set_e0
 	cmpb $0xe1,%al
 	je set_e1
-	call key_table(,%eax,4)
+	call *key_table(,%eax,4)
 	movb $0,e0
 e0_e1:	inb $0x61,%al
 	jmp 1f
@@ -56,7 +56,7 @@
 	movb $0x20,%al
 	outb %al,$0x20
 	pushl $0
-	call _do_tty_interrupt
+	call do_tty_interrupt
 	addl $4,%esp
 	pop %es
 	pop %ds
@@ -78,7 +78,7 @@
 put_queue:
 	pushl %ecx
 	pushl %edx
-	movl _table_list,%edx		# read-queue for console
+	movl table_list,%edx		# read-queue for console
 	movl head(%edx),%ecx
 1:	movb %al,buf(%edx,%ecx)
 	incl %ecx
diff -Naur linux/kernel/Makefile linux_working/linux-0.01-master/kernel/Makefile
--- linux/kernel/Makefile	1991-09-17 20:45:06.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/Makefile	2013-09-18 12:48:30.000000000 +0530
@@ -6,20 +6,20 @@
 # unless it's something special (ie not a .c file).
 #
 
-AR	=gar
-AS	=gas
-LD	=gld
-LDFLAGS	=-s -x
+AR	=ar
+AS	=as --32
+LD	=ld -m  elf_i386 
+LDFLAGS	=-g #-s -x
 CC	=gcc
-CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs \
-	-finline-functions -mstring-insns -nostdinc -I../include
+CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -m32 \
+	-finline-functions -fno-stack-protector -nostdinc -fno-builtin -g -I../include
 CPP	=gcc -E -nostdinc -I../include
 
 .c.s:
 	$(CC) $(CFLAGS) \
 	-S -o $*.s $<
 .s.o:
-	$(AS) -c -o $*.o $<
+	$(AS) -o $*.o $<
 .c.o:
 	$(CC) $(CFLAGS) \
 	-c -o $*.o $<
diff -Naur linux/kernel/panic.c linux_working/linux-0.01-master/kernel/panic.c
--- linux/kernel/panic.c	1991-08-19 03:36:41.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/panic.c	2013-09-18 12:48:30.000000000 +0530
@@ -4,7 +4,7 @@
  */
 #include <linux/kernel.h>
 
-volatile void panic(const char * s)
+void panic(const char * s)
 {
 	printk("Kernel panic: %s\n\r",s);
 	for(;;);
diff -Naur linux/kernel/printk.c linux_working/linux-0.01-master/kernel/printk.c
--- linux/kernel/printk.c	1991-09-17 20:38:59.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/printk.c	2013-09-18 12:48:30.000000000 +0530
@@ -8,6 +8,7 @@
 
 #include <linux/kernel.h>
 
+extern int vsprintf();
 static char buf[1024];
 
 int printk(const char *fmt, ...)
@@ -22,9 +23,9 @@
 		"push %%ds\n\t"
 		"pop %%fs\n\t"
 		"pushl %0\n\t"
-		"pushl $_buf\n\t"
+		"pushl $buf\n\t"
 		"pushl $0\n\t"
-		"call _tty_write\n\t"
+		"call tty_write\n\t"
 		"addl $8,%%esp\n\t"
 		"popl %0\n\t"
 		"pop %%fs"
diff -Naur linux/kernel/rs_io.s linux_working/linux-0.01-master/kernel/rs_io.s
--- linux/kernel/rs_io.s	1991-09-17 21:59:55.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/rs_io.s	2013-09-18 12:48:30.000000000 +0530
@@ -5,7 +5,7 @@
  */
 
 .text
-.globl _rs1_interrupt,_rs2_interrupt
+.globl rs1_interrupt,rs2_interrupt
 
 size	= 1024				/* must be power of two !
 					   and must match the value
@@ -25,12 +25,12 @@
  * the interrupt is coming from, and take appropriate action.
  */
 .align 2
-_rs1_interrupt:
-	pushl $_table_list+8
+rs1_interrupt:
+	pushl $table_list+8
 	jmp rs_int
 .align 2
-_rs2_interrupt:
-	pushl $_table_list+16
+rs2_interrupt:
+	pushl $table_list+16
 rs_int:
 	pushl %edx
 	pushl %ecx
@@ -56,7 +56,7 @@
 	movl 24(%esp),%ecx
 	pushl %edx
 	subl $2,%edx
-	call jmp_table(,%eax,2)		/* NOTE! not *4, bit0 is 0 already */
+	call *jmp_table(,%eax,2)		/* NOTE! not *4, bit0 is 0 already */
 	popl %edx
 	jmp rep_int
 end:	movb $0x20,%al
@@ -89,7 +89,7 @@
 read_char:
 	inb %dx,%al
 	movl %ecx,%edx
-	subl $_table_list,%edx
+	subl $table_list,%edx
 	shrl $3,%edx
 	movl (%ecx),%ecx		# read-queue
 	movl head(%ecx),%ebx
@@ -100,7 +100,7 @@
 	je 1f
 	movl %ebx,head(%ecx)
 	pushl %edx
-	call _do_tty_interrupt
+	call do_tty_interrupt
 	addl $4,%esp
 1:	ret
 
diff -Naur linux/kernel/sys.c linux_working/linux-0.01-master/kernel/sys.c
--- linux/kernel/sys.c	1991-09-17 18:02:52.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/sys.c	2013-09-18 12:48:30.000000000 +0530
@@ -193,10 +193,17 @@
 	return current->pgrp;
 }
 
+int sys_oldolduname(void* v)
+{
+	printk("calling obsolete system call oldolduname\n");
+	return -ENOSYS;
+//	return (0);
+}
+
 int sys_uname(struct utsname * name)
 {
 	static struct utsname thisname = {
-		"linux .0","nodename","release ","version ","machine "
+		"linux 0.01-3.x","nodename","release ","3.x","i386"
 	};
 	int i;
 
@@ -214,3 +221,17 @@
 	current->umask = mask & 0777;
 	return (old);
 }
+
+int sys_null(int nr)
+{
+	static int prev_nr=-2;
+	if (nr==174 || nr==175) return -ENOSYS;
+
+	if (prev_nr!=nr) 
+	{
+		prev_nr=nr;
+//		printk("system call num %d not available\n",nr);
+	}
+	return -ENOSYS;
+}
+
diff -Naur linux/kernel/system_call.s linux_working/linux-0.01-master/kernel/system_call.s
--- linux/kernel/system_call.s	1991-09-17 21:20:52.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/system_call.s	2013-09-18 12:48:30.000000000 +0530
@@ -45,9 +45,9 @@
 restorer = 16		# address of info-restorer
 sig_fn	= 20		# table of 32 signal addresses
 
-nr_system_calls = 67
+nr_system_calls = 319
 
-.globl _system_call,_sys_fork,_timer_interrupt,_hd_interrupt,_sys_execve
+.globl system_call,sys_fork,timer_interrupt,hd_interrupt,sys_execve
 
 .align 2
 bad_sys_call:
@@ -56,9 +56,9 @@
 .align 2
 reschedule:
 	pushl $ret_from_sys_call
-	jmp _schedule
+	jmp schedule
 .align 2
-_system_call:
+system_call:
 	cmpl $nr_system_calls-1,%eax
 	ja bad_sys_call
 	push %ds
@@ -72,16 +72,24 @@
 	mov %dx,%es
 	movl $0x17,%edx		# fs points to local data space
 	mov %dx,%fs
-	call _sys_call_table(,%eax,4)
+
+	movl sys_call_table(,%eax,4),%edx	# if sys_null
+	cmpl $sys_null,%edx					# then the syscall is not
+	jne 1f								# implemented.
+	popl  %edx							# 1st argument is syscall nr
+	pushl %eax
+1:
+
+	call *sys_call_table(,%eax,4)
 	pushl %eax
-	movl _current,%eax
+	movl current,%eax
 	cmpl $0,state(%eax)		# state
 	jne reschedule
 	cmpl $0,counter(%eax)		# counter
 	je reschedule
 ret_from_sys_call:
-	movl _current,%eax		# task[0] cannot have signals
-	cmpl _task,%eax
+	movl current,%eax		# task[0] cannot have signals
+	cmpl task,%eax
 	je 3f
 	movl CS(%esp),%ebx		# was old code segment supervisor
 	testl $3,%ebx			# mode? If so - don't check signals
@@ -106,7 +114,7 @@
 	pushl %ecx
 	pushl $28
 	pushl %edx
-	call _verify_area
+	call verify_area
 	popl %edx
 	addl $4,%esp
 	popl %ecx
@@ -137,12 +145,12 @@
 	cmpl $SIG_CHLD,%ecx
 	je 2b
 	pushl %ecx
-	call _do_exit		# remember to set bit 7 when dumping core
+	call do_exit		# remember to set bit 7 when dumping core
 	addl $4,%esp
 	jmp 3b
 
 .align 2
-_timer_interrupt:
+timer_interrupt:
 	push %ds		# save ds,es and put kernel data space
 	push %es		# into them. %fs is used by _system_call
 	push %fs
@@ -155,27 +163,27 @@
 	mov %ax,%es
 	movl $0x17,%eax
 	mov %ax,%fs
-	incl _jiffies
+	incl jiffies
 	movb $0x20,%al		# EOI to interrupt controller #1
 	outb %al,$0x20
 	movl CS(%esp),%eax
 	andl $3,%eax		# %eax is CPL (0 or 3, 0=supervisor)
 	pushl %eax
-	call _do_timer		# 'do_timer(long CPL)' does everything from
+	call do_timer		# 'do_timer(long CPL)' does everything from
 	addl $4,%esp		# task switching to accounting ...
 	jmp ret_from_sys_call
 
 .align 2
-_sys_execve:
+sys_execve:
 	lea EIP(%esp),%eax
 	pushl %eax
-	call _do_execve
+	call do_execve
 	addl $4,%esp
 	ret
 
 .align 2
-_sys_fork:
-	call _find_empty_process
+sys_fork:
+	call find_empty_process
 	testl %eax,%eax
 	js 1f
 	push %gs
@@ -183,11 +191,11 @@
 	pushl %edi
 	pushl %ebp
 	pushl %eax
-	call _copy_process
+	call copy_process
 	addl $20,%esp
 1:	ret
 
-_hd_interrupt:
+hd_interrupt:
 	pushl %eax
 	pushl %ecx
 	pushl %edx
@@ -204,10 +212,10 @@
 	jmp 1f			# give port chance to breathe
 1:	jmp 1f
 1:	outb %al,$0xA0		# same to controller #2
-	movl _do_hd,%eax
+	movl do_hd,%eax
 	testl %eax,%eax
 	jne 1f
-	movl $_unexpected_hd_interrupt,%eax
+	movl $unexpected_hd_interrupt,%eax
 1:	call *%eax		# "interesting" way of handling intr.
 	pop %fs
 	pop %es
diff -Naur linux/kernel/tty_io.c linux_working/linux-0.01-master/kernel/tty_io.c
--- linux/kernel/tty_io.c	1991-09-17 21:22:19.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/tty_io.c	2013-09-18 12:48:30.000000000 +0530
@@ -206,7 +206,7 @@
 	minimum = (unsigned) tty->termios.c_cc[VMIN];
 	if (time && !minimum) {
 		minimum=1;
-		if (flag=(!oldalarm || time+jiffies<oldalarm))
+		if ((flag=(!oldalarm || time+jiffies<oldalarm)))
 			current->alarm = time+jiffies;
 	}
 	if (minimum>nr)
@@ -235,11 +235,12 @@
 					break;
 			}
 		} while (nr>0 && !EMPTY(tty->secondary));
-		if (time && !L_CANON(tty))
-			if (flag=(!oldalarm || time+jiffies<oldalarm))
+		if (time && !L_CANON(tty)) {
+			if ((flag=(!oldalarm || time+jiffies<oldalarm)))
 				current->alarm = time+jiffies;
 			else
 				current->alarm = oldalarm;
+		}
 		if (L_CANON(tty)) {
 			if (b-buf)
 				break;
@@ -254,7 +255,7 @@
 
 int tty_write(unsigned channel, char * buf, int nr)
 {
-	static cr_flag=0;
+	static int cr_flag=0;
 	struct tty_struct * tty;
 	char c, *b=buf;
 
diff -Naur linux/kernel/vsprintf.c linux_working/linux-0.01-master/kernel/vsprintf.c
--- linux/kernel/vsprintf.c	1991-08-11 23:29:51.000000000 +0530
+++ linux_working/linux-0.01-master/kernel/vsprintf.c	2013-09-18 12:48:30.000000000 +0530
@@ -49,9 +49,10 @@
 	} else
 		sign=(type&PLUS) ? '+' : ((type&SPACE) ? ' ' : 0);
 	if (sign) size--;
-	if (type&SPECIAL)
+	if (type&SPECIAL){
 		if (base==16) size -= 2;
 		else if (base==8) size--;
+	}
 	i=0;
 	if (num==0)
 		tmp[i++]='0';
@@ -64,13 +65,14 @@
 			*str++ = ' ';
 	if (sign)
 		*str++ = sign;
-	if (type&SPECIAL)
+	if (type&SPECIAL) {
 		if (base==8)
 			*str++ = '0';
 		else if (base==16) {
 			*str++ = '0';
 			*str++ = digits[33];
 		}
+	}
 	if (!(type&LEFT))
 		while(size-->0)
 			*str++ = c;
diff -Naur linux/lib/ctype.c linux_working/linux-0.01-master/lib/ctype.c
--- linux/lib/ctype.c	1991-09-17 20:47:15.000000000 +0530
+++ linux_working/linux-0.01-master/lib/ctype.c	2013-09-18 12:48:30.000000000 +0530
@@ -1,6 +1,6 @@
 #include <ctype.h>
 
-char _ctmp;
+signed char _ctmp;
 unsigned char _ctype[] = {0x00,			/* EOF */
 _C,_C,_C,_C,_C,_C,_C,_C,			/* 0-7 */
 _C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C,		/* 8-15 */
diff -Naur linux/lib/_exit.c linux_working/linux-0.01-master/lib/_exit.c
--- linux/lib/_exit.c	1991-09-17 20:53:55.000000000 +0530
+++ linux_working/linux-0.01-master/lib/_exit.c	2013-09-18 12:48:30.000000000 +0530
@@ -1,7 +1,7 @@
 #define __LIBRARY__
 #include <unistd.h>
 
-volatile void _exit(int exit_code)
+void _exit(int exit_code)
 {
 	__asm__("int $0x80"::"a" (__NR_exit),"b" (exit_code));
 }
diff -Naur linux/lib/Makefile linux_working/linux-0.01-master/lib/Makefile
--- linux/lib/Makefile	1991-09-17 20:59:52.000000000 +0530
+++ linux_working/linux-0.01-master/lib/Makefile	2013-09-18 12:48:30.000000000 +0530
@@ -6,20 +6,20 @@
 # unless it's something special (ie not a .c file).
 #
 
-AR	=gar
-AS	=gas
-LD	=gld
-LDFLAGS	=-s -x
+AR	=ar
+AS	=as --32
+LD	=ld -m  elf_i386
+LDFLAGS	=-g #-s -x
 CC	=gcc
-CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs \
-	-finline-functions -mstring-insns -nostdinc -I../include
+CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -m32\
+	-finline-functions -fno-stack-protector -nostdinc -fno-builtin -g -I../include
 CPP	=gcc -E -nostdinc -I../include
 
 .c.s:
 	$(CC) $(CFLAGS) \
 	-S -o $*.s $<
 .s.o:
-	$(AS) -c -o $*.o $<
+	$(AS) -o $*.o $<
 .c.o:
 	$(CC) $(CFLAGS) \
 	-c -o $*.o $<
diff -Naur linux/Makefile linux_working/linux-0.01-master/Makefile
--- linux/Makefile	1991-09-17 19:23:58.000000000 +0530
+++ linux_working/linux-0.01-master/Makefile	2013-09-18 12:48:30.000000000 +0530
@@ -4,15 +4,16 @@
 # remove them from the CFLAGS defines.
 #
 
-AS86	=as -0 -a
-CC86	=cc -0
-LD86	=ld -0
-
-AS	=gas
-LD	=gld
-LDFLAGS	=-s -x -M
+AS86	=as86 -0 
+CC86	=cc86 -0
+LD86	=ld86 -0
+
+AS	=as --32 
+LD	=ld -m  elf_i386 
+LDFLAGS	=-M -Ttext 0 -e startup_32
+#LDFLAGS	=-s -x -M -Ttext 0 -e startup_32
 CC	=gcc
-CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs
+CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fno-stack-protector -fno-builtin -g -m32
 CPP	=gcc -E -nostdinc -Iinclude
 
 ARCHIVES=kernel/kernel.o mm/mm.o fs/fs.o
@@ -22,7 +23,7 @@
 	$(CC) $(CFLAGS) \
 	-nostdinc -Iinclude -S -o $*.s $<
 .s.o:
-	$(AS) -c -o $*.o $<
+	$(AS) --32 -o $*.o $<
 .c.o:
 	$(CC) $(CFLAGS) \
 	-nostdinc -Iinclude -c -o $*.o $<
@@ -30,13 +31,14 @@
 all:	Image
 
 Image: boot/boot tools/system tools/build
-	tools/build boot/boot tools/system > Image
-	sync
+	objcopy  -O binary -R .note -R .comment tools/system tools/system.bin
+	tools/build boot/boot tools/system.bin > Image
+#	sync
 
 tools/build: tools/build.c
 	$(CC) $(CFLAGS) \
 	-o tools/build tools/build.c
-	chmem +65000 tools/build
+	#chmem +65000 tools/build
 
 boot/head.o: boot/head.s
 
@@ -60,8 +62,8 @@
 	(cd lib; make)
 
 boot/boot:	boot/boot.s tools/system
-	(echo -n "SYSSIZE = (";ls -l tools/system | grep system \
-		| cut -c25-31 | tr '\012' ' '; echo "+ 15 ) / 16") > tmp.s
+	(echo -n "SYSSIZE = (";stat -c%s tools/system \
+		| tr '\012' ' '; echo "+ 15 ) / 16") > tmp.s	
 	cat boot/boot.s >> tmp.s
 	$(AS86) -o boot/boot.o tmp.s
 	rm -f tmp.s
@@ -69,7 +71,7 @@
 
 clean:
 	rm -f Image System.map tmp_make boot/boot core
-	rm -f init/*.o boot/*.o tools/system tools/build
+	rm -f init/*.o boot/*.o tools/system tools/build tools/system.bin
 	(cd mm;make clean)
 	(cd fs;make clean)
 	(cd kernel;make clean)
@@ -77,7 +79,7 @@
 
 backup: clean
 	(cd .. ; tar cf - linux | compress16 - > backup.Z)
-	sync
+#	sync
 
 dep:
 	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
diff -Naur linux/mm/Makefile linux_working/linux-0.01-master/mm/Makefile
--- linux/mm/Makefile	1991-09-17 20:45:07.000000000 +0530
+++ linux_working/linux-0.01-master/mm/Makefile	2013-09-18 12:48:30.000000000 +0530
@@ -1,9 +1,9 @@
 CC	=gcc
-CFLAGS	=-O -Wall -fstrength-reduce -fcombine-regs -fomit-frame-pointer \
-	-finline-functions -nostdinc -I../include
-AS	=gas
-AR	=gar
-LD	=gld
+CFLAGS	=-O -Wall -fstrength-reduce  -fomit-frame-pointer -m32 \
+	-fno-stack-protector -finline-functions -nostdinc -fno-builtin -g -I../include
+AS	=as --32
+AR	=ar 
+LD	=ld -m  elf_i386 
 CPP	=gcc -E -nostdinc -I../include
 
 .c.o:
diff -Naur linux/mm/memory.c linux_working/linux-0.01-master/mm/memory.c
--- linux/mm/memory.c	1991-09-17 20:37:00.000000000 +0530
+++ linux_working/linux-0.01-master/mm/memory.c	2013-09-18 12:48:30.000000000 +0530
@@ -3,12 +3,19 @@
 #include <linux/config.h>
 #include <linux/head.h>
 #include <linux/kernel.h>
+#include <linux/mm.h>
 #include <asm/system.h>
 
 int do_exit(long code);
 
-#define invalidate() \
-__asm__("movl %%eax,%%cr3"::"a" (0))
+inline void invalidate()
+{
+	int d0;
+	__asm__ __volatile(
+		"movl %%eax,%%cr3"
+		:"=&a" (d0)
+		:"0" (0) );
+}
 
 #if (BUFFER_END < 0x100000)
 #define LOW_MEM 0x100000
@@ -25,8 +32,16 @@
 #error "Won't work"
 #endif
 
-#define copy_page(from,to) \
-__asm__("cld ; rep ; movsl"::"S" (from),"D" (to),"c" (1024):"cx","di","si")
+inline void copy_page(unsigned long from,unsigned long to)
+{
+int d0,d1,d2;
+__asm__ __volatile("cld\n\t"
+	"rep\n\t"
+	"movsl\n\t"
+	:"=&c" (d0), "=&S" (d1), "=&D" (d2)
+	:"0" (PAGE_SIZE/4),"1" (from),"2" (to)
+	:"memory");
+}
 
 static unsigned short mem_map [ PAGING_PAGES ] = {0,};
 
@@ -36,9 +51,9 @@
  */
 unsigned long get_free_page(void)
 {
-register unsigned long __res asm("ax");
+register unsigned long __res;
 
-__asm__("std ; repne ; scasw\n\t"
+__asm__ __volatile__("std ; repne ; scasw\n\t"
 	"jne 1f\n\t"
 	"movw $1,2(%%edi)\n\t"
 	"sall $12,%%ecx\n\t"
@@ -52,7 +67,7 @@
 	:"=a" (__res)
 	:"0" (0),"i" (LOW_MEM),"c" (PAGING_PAGES),
 	"D" (mem_map+PAGING_PAGES-1)
-	:"di","cx","dx");
+	:"dx");
 return __res;
 }
 
@@ -80,7 +95,6 @@
 {
 	unsigned long *pg_table;
 	unsigned long * dir, nr;
-
 	if (from & 0x3fffff)
 		panic("free_page_tables called with wrong alignment");
 	if (!from)
@@ -238,7 +252,7 @@
 {
 	unsigned long tmp;
 
-	if (tmp=get_free_page())
+	if ((tmp=get_free_page()))
 		if (put_page(tmp,address))
 			return;
 	do_exit(SIGSEGV);
diff -Naur linux/mm/page.s linux_working/linux-0.01-master/mm/page.s
--- linux/mm/page.s	1991-06-30 00:20:16.000000000 +0530
+++ linux_working/linux-0.01-master/mm/page.s	2013-09-18 12:48:30.000000000 +0530
@@ -3,9 +3,9 @@
  * the real work is done in mm.c
  */
 
-.globl _page_fault
+.globl page_fault
 
-_page_fault:
+page_fault:
 	xchgl %eax,(%esp)
 	pushl %ecx
 	pushl %edx
@@ -21,9 +21,9 @@
 	pushl %eax
 	testl $1,%eax
 	jne 1f
-	call _do_no_page
+	call do_no_page
 	jmp 2f
-1:	call _do_wp_page
+1:	call do_wp_page
 2:	addl $8,%esp
 	pop %fs
 	pop %es
diff -Naur linux/tools/build.c linux_working/linux-0.01-master/tools/build.c
--- linux/tools/build.c	1991-07-02 22:50:24.000000000 +0530
+++ linux_working/linux-0.01-master/tools/build.c	2013-09-18 12:48:30.000000000 +0530
@@ -3,6 +3,7 @@
 #include <sys/types.h>	/* unistd.h needs this */
 #include <unistd.h>	/* contains read/write */
 #include <fcntl.h>
+#include <string.h>
 
 #define MINIX_HEADER 32
 #define GCC_HEADER 1024
@@ -55,13 +56,20 @@
 	
 	if ((id=open(argv[2],O_RDONLY,0))<0)
 		die("Unable to open 'system'");
-	if (read(id,buf,GCC_HEADER) != GCC_HEADER)
-		die("Unable to read header of 'system'");
-	if (((long *) buf)[5] != 0)
-		die("Non-GCC header of 'system'");
+//	if (read(id,buf,GCC_HEADER) != GCC_HEADER)
+//		die("Unable to read header of 'system'");
+//	if (((long *) buf)[5] != 0)
+//		die("Non-GCC header of 'system'");
 	for (i=0 ; (c=read(id,buf,sizeof buf))>0 ; i+=c )
 		if (write(1,buf,c)!=c)
 			die("Write call failed");
+
+	/* only needed by qemu. ( qemu may not read last sector if
+ 	 * size is < 512 bytes ) 
+ 	 */
+	memset(buf,0,512);
+	write(1,buf,512);	
+
 	close(id);
 	fprintf(stderr,"System %d bytes.\n",i);
 	return(0);
